"(function () {\n  var setTimeoutWrapper;\n  var createIterator = function (generatorWrapper) {\n    var value = 0;\n    return function () {\n      if (value < generatorWrapper.length) {\n        return {\n          done: false,\n          value: generatorWrapper[value++]\n        };\n      } else {\n        return {\n          done: true\n        };\n      }\n    };\n  };\n  var definePropertyPolyfill = typeof Object.defineProperties == \"function\" ? Object.defineProperty : function (generatorWrapper, value, CustomMap) {\n    if (generatorWrapper == Array.prototype || generatorWrapper == Object.prototype) {\n      return generatorWrapper;\n    }\n    generatorWrapper[value] = CustomMap.value;\n    return generatorWrapper;\n  };\n  var findGlobalObject = function (generatorWrapper) {\n    generatorWrapper = [typeof globalThis == \"object\" && globalThis, generatorWrapper, typeof window == \"object\" && window, typeof self == \"object\" && self, typeof global == \"object\" && global];\n    for (var value = 0; value < generatorWrapper.length; ++value) {\n      var CustomMap = generatorWrapper[value];\n      if (CustomMap && CustomMap.Math == Math) {\n        return CustomMap;\n      }\n    }\n    throw Error(\"Cannot find global object\");\n  };\n  var globalObject = findGlobalObject(this);\n  var definePolyfill = function (generatorWrapper, value) {\n    if (value) {\n      generatorWrapper: {\n        var CustomMap = globalObject;\n        generatorWrapper = generatorWrapper.split(\".\");\n        for (var findEntry = 0; findEntry < generatorWrapper.length - 1; findEntry++) {\n          var iterateEntries = generatorWrapper[findEntry];\n          if (!(iterateEntries in CustomMap)) {\n            break generatorWrapper;\n          }\n          CustomMap = CustomMap[iterateEntries];\n        }\n        generatorWrapper = generatorWrapper[generatorWrapper.length - 1];\n        findEntry = CustomMap[generatorWrapper];\n        value = value(findEntry);\n        if (value != findEntry && value != null) {\n          definePropertyPolyfill(CustomMap, generatorWrapper, {\n            configurable: true,\n            writable: true,\n            value: value\n          });\n        }\n      }\n    }\n  };\n  definePolyfill(\"Symbol\", function (generatorWrapper) {\n    if (generatorWrapper) {\n      return generatorWrapper;\n    }\n    var value = function (createCircularNode, entryIdCounter) {\n      this.entryIdCounter = createCircularNode;\n      definePropertyPolyfill(this, \"description\", {\n        configurable: true,\n        writable: true,\n        value: entryIdCounter\n      });\n    };\n    value.prototype.toString = function () {\n      return this.entryIdCounter;\n    };\n    var CustomMap = \"jscomp_symbol_\" + (1000000000 * Math.random() >>> 0) + \"_\";\n    var findEntry = 0;\n    var iterateEntries = function (createCircularNode) {\n      if (this instanceof iterateEntries) {\n        throw new TypeError(\"Symbol is not a constructor\");\n      }\n      return new value(CustomMap + (createCircularNode || \"\") + \"_\" + findEntry++, createCircularNode);\n    };\n    return iterateEntries;\n  });\n  definePolyfill(\"Symbol.iterator\", function (generatorWrapper) {\n    if (generatorWrapper) {\n      return generatorWrapper;\n    }\n    generatorWrapper = Symbol(\"Symbol.iterator\");\n    for (var value = \"Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".split(\" \"), CustomMap = 0; CustomMap < value.length; CustomMap++) {\n      var findEntry = globalObject[value[CustomMap]];\n      if (typeof findEntry === \"function\" && typeof findEntry.prototype[generatorWrapper] != \"function\") {\n        definePropertyPolyfill(findEntry.prototype, generatorWrapper, {\n          configurable: true,\n          writable: true,\n          value() {\n            return createIterator(createIterator(this));\n          }\n        });\n      }\n    }\n    return generatorWrapper;\n  });\n  var createIterator = function (generatorWrapper) {\n    generatorWrapper = {\n      next: generatorWrapper\n    };\n    generatorWrapper[Symbol.iterator] = function () {\n      return this;\n    };\n    return generatorWrapper;\n  };\n  var identityFunction = function (generatorWrapper) {\n    return generatorWrapper.raw = generatorWrapper;\n  };\n  var getIterator = function (generatorWrapper) {\n    var value = typeof Symbol != \"undefined\" && Symbol.iterator && generatorWrapper[Symbol.iterator];\n    if (value) {\n      return value.call(generatorWrapper);\n    }\n    if (typeof generatorWrapper.length == \"number\") {\n      return {\n        next: createIterator(generatorWrapper)\n      };\n    }\n    throw Error(String(generatorWrapper) + \" is not an iterable or ArrayLike\");\n  };\n  var toArray = function (generatorWrapper) {\n    if (!(generatorWrapper instanceof Array)) {\n      generatorWrapper = getIterator(generatorWrapper);\n      for (var value, CustomMap = []; !(value = generatorWrapper.next()).done;) {\n        CustomMap.push(value.value);\n      }\n      generatorWrapper = CustomMap;\n    }\n    return generatorWrapper;\n  };\n  var hasOwnPropertySafe = function (generatorWrapper, value) {\n    return Object.prototype.hasOwnProperty.call(generatorWrapper, value);\n  };\n  var assignPolyfill = typeof Object.assign == \"function\" ? Object.assign : function (generatorWrapper, value) {\n    for (var CustomMap = 1; CustomMap < arguments.length; CustomMap++) {\n      var findEntry = arguments[CustomMap];\n      if (findEntry) {\n        for (var iterateEntries in findEntry) if (hasOwnPropertySafe(findEntry, iterateEntries)) {\n          generatorWrapper[iterateEntries] = findEntry[iterateEntries];\n        }\n      }\n    }\n    return generatorWrapper;\n  };\n  definePolyfill(\"Object.assign\", function (generatorWrapper) {\n    return generatorWrapper || assignPolyfill;\n  });\n  var setPrototypeOfPolyfill;\n  var createObjectPolyfill = typeof Object.create == \"function\" ? Object.create : function (generatorWrapper) {\n    var value = function () {};\n    value.prototype = generatorWrapper;\n    return new value();\n  };\n  var constructReflect = function () {\n    function generatorWrapper() {\n      function CustomMap() {}\n      new CustomMap();\n      Reflect.construct(CustomMap, [], function () {});\n      return new CustomMap() instanceof CustomMap;\n    }\n    if (typeof Reflect != \"undefined\" && Reflect.construct) {\n      if (generatorWrapper()) {\n        return Reflect.construct;\n      }\n      var value = Reflect.construct;\n      return function (CustomMap, findEntry, iterateEntries) {\n        CustomMap = value(CustomMap, findEntry);\n        if (iterateEntries) {\n          Reflect.setPrototypeOf(CustomMap, iterateEntries.prototype);\n        }\n        return CustomMap;\n      };\n    }\n    return function (CustomMap, findEntry, iterateEntries) {\n      if (undefined === iterateEntries) {\n        iterateEntries = CustomMap;\n      }\n      iterateEntries = createObjectPolyfill(iterateEntries.prototype || Object.prototype);\n      return Function.prototype.apply.call(CustomMap, iterateEntries, findEntry) || iterateEntries;\n    };\n  }();\n  if (typeof Object.setPrototypeOf == \"function\") {\n    setPrototypeOfPolyfill = Object.setPrototypeOf;\n  } else {\n    var adData;\n    generatorWrapper: {\n      var sa = {\n        generatorWrapper: true\n      };\n      var ta = {};\n      try {\n        ta.__proto__ = sa;\n        adData = ta.generatorWrapper;\n        break generatorWrapper;\n      } catch (generatorWrapper) {}\n      adData = false;\n    }\n    if (adData) {\n      setPrototypeOfPolyfill = function (generatorWrapper, value) {\n        generatorWrapper.__proto__ = value;\n        if (generatorWrapper.__proto__ !== value) {\n          throw new TypeError(generatorWrapper + \" is not extensible\");\n        }\n        return generatorWrapper;\n      };\n    } else {\n      setPrototypeOfPolyfill = null;\n    }\n  }\n  var setPrototypeOfPolyfill = setPrototypeOfPolyfill;\n  var inheritPrototype = function (generatorWrapper, value) {\n    generatorWrapper.prototype = createObjectPolyfill(value.prototype);\n    generatorWrapper.prototype.constructor = generatorWrapper;\n    if (setPrototypeOfPolyfill) {\n      setPrototypeOfPolyfill(generatorWrapper, value);\n    } else {\n      for (var CustomMap in value) if (CustomMap != \"prototype\") {\n        if (Object.defineProperties) {\n          var findEntry = Object.getOwnPropertyDescriptor(value, CustomMap);\n          if (findEntry) {\n            Object.defineProperty(generatorWrapper, CustomMap, findEntry);\n          }\n        } else {\n          generatorWrapper[CustomMap] = value[CustomMap];\n        }\n      }\n    }\n    generatorWrapper.executeGeneratorAsPromise = value.prototype;\n  };\n  var Generator = function () {\n    this.isDone = false;\n    this.createDeferred = null;\n    this.tasks = undefined;\n    this.entryIdCounter = 1;\n    this.settlePromise = this.setTimeoutWrapper = 0;\n    this.handleAsync = null;\n  };\n  var resetGeneratorState = function (generatorWrapper) {\n    if (generatorWrapper.isDone) {\n      throw new TypeError(\"Generator is already running\");\n    }\n    generatorWrapper.isDone = true;\n  };\n  Generator.prototype.onFulfilled = function (generatorWrapper) {\n    this.tasks = generatorWrapper;\n  };\n  var handleGeneratorError = function (generatorWrapper, value) {\n    generatorWrapper.handleAsync = {\n      polyfillCheckCache: value,\n      stringOrNumberTransformation2: true\n    };\n    generatorWrapper.entryIdCounter = generatorWrapper.setTimeoutWrapper || generatorWrapper.settlePromise;\n  };\n  Generator.prototype.return = function (generatorWrapper) {\n    this.handleAsync = {\n      return: generatorWrapper\n    };\n    this.entryIdCounter = this.settlePromise;\n  };\n  var generatorYield = function (generatorWrapper, value, CustomMap) {\n    generatorWrapper.entryIdCounter = CustomMap;\n    return {\n      value: value\n    };\n  };\n  var resetGeneratorState = function (generatorWrapper) {\n    generatorWrapper.entryIdCounter = 0;\n    generatorWrapper.setTimeoutWrapper = 0;\n  };\n  var getGeneratorException = function (generatorWrapper) {\n    generatorWrapper.setTimeoutWrapper = 0;\n    var value = generatorWrapper.handleAsync.polyfillCheckCache;\n    generatorWrapper.handleAsync = null;\n    return value;\n  };\n  var GeneratorFunctionConstructor = function (generatorWrapper) {\n    this.entryIdCounter = new Generator();\n    this.tasks = generatorWrapper;\n  };\n  var generatorReturn = function (generatorWrapper, value) {\n    resetGeneratorState(generatorWrapper.entryIdCounter);\n    var CustomMap = generatorWrapper.entryIdCounter.createDeferred;\n    if (CustomMap) {\n      return handleIteratorResult(generatorWrapper, \"return\" in CustomMap ? CustomMap[\"return\"] : function (findEntry) {\n        return {\n          value: findEntry,\n          done: true\n        };\n      }, value, generatorWrapper.entryIdCounter.return);\n    }\n    generatorWrapper.entryIdCounter.return(value);\n    return finalizeGenerator(generatorWrapper);\n  };\n  var handleIteratorResult = function (generatorWrapper, value, CustomMap, findEntry) {\n    try {\n      var iterateEntries = value.call(generatorWrapper.entryIdCounter.createDeferred, CustomMap);\n      if (!(iterateEntries instanceof Object)) {\n        throw new TypeError(\"Iterator result \" + iterateEntries + \" is not an object\");\n      }\n      if (!iterateEntries.done) {\n        generatorWrapper.entryIdCounter.isDone = false;\n        return iterateEntries;\n      }\n      var createCircularNode = iterateEntries.value;\n    } catch (entryIdCounter) {\n      generatorWrapper.entryIdCounter.createDeferred = null;\n      handleGeneratorError(generatorWrapper.entryIdCounter, entryIdCounter);\n      return finalizeGenerator(generatorWrapper);\n    }\n    generatorWrapper.entryIdCounter.createDeferred = null;\n    findEntry.call(generatorWrapper.entryIdCounter, createCircularNode);\n    return finalizeGenerator(generatorWrapper);\n  };\n  var finalizeGenerator = function (generatorWrapper) {\n    for (; generatorWrapper.entryIdCounter.entryIdCounter;) {\n      try {\n        var value = generatorWrapper.tasks(generatorWrapper.entryIdCounter);\n        if (value) {\n          generatorWrapper.entryIdCounter.isDone = false;\n          return {\n            value: value.value,\n            done: false\n          };\n        }\n      } catch (CustomMap) {\n        generatorWrapper.entryIdCounter.tasks = undefined;\n        handleGeneratorError(generatorWrapper.entryIdCounter, CustomMap);\n      }\n    }\n    generatorWrapper.entryIdCounter.isDone = false;\n    if (generatorWrapper.entryIdCounter.handleAsync) {\n      value = generatorWrapper.entryIdCounter.handleAsync;\n      generatorWrapper.entryIdCounter.handleAsync = null;\n      if (value.stringOrNumberTransformation2) {\n        throw value.polyfillCheckCache;\n      }\n      return {\n        value: value.return,\n        done: true\n      };\n    }\n    return {\n      value: undefined,\n      done: true\n    };\n  };\n  var GeneratorExecutor = function (generatorWrapper) {\n    this.next = function (value) {\n      resetGeneratorState(generatorWrapper.entryIdCounter);\n      if (generatorWrapper.entryIdCounter.createDeferred) {\n        value = handleIteratorResult(generatorWrapper, generatorWrapper.entryIdCounter.createDeferred.next, value, generatorWrapper.entryIdCounter.onFulfilled);\n      } else {\n        generatorWrapper.entryIdCounter.onFulfilled(value);\n        value = finalizeGenerator(generatorWrapper);\n      }\n      return value;\n    };\n    this.throw = function (value) {\n      resetGeneratorState(generatorWrapper.entryIdCounter);\n      if (generatorWrapper.entryIdCounter.createDeferred) {\n        value = handleIteratorResult(generatorWrapper, generatorWrapper.entryIdCounter.createDeferred[\"throw\"], value, generatorWrapper.entryIdCounter.onFulfilled);\n      } else {\n        handleGeneratorError(generatorWrapper.entryIdCounter, value);\n        value = finalizeGenerator(generatorWrapper);\n      }\n      return value;\n    };\n    this.return = function (value) {\n      return generatorReturn(generatorWrapper, value);\n    };\n    this[Symbol.iterator] = function () {\n      return this;\n    };\n  };\n  var executeGeneratorAsPromise = function (generatorWrapper) {\n    function value(findEntry) {\n      return generatorWrapper.next(findEntry);\n    }\n    function CustomMap(findEntry) {\n      return generatorWrapper.throw(findEntry);\n    }\n    return new Promise(function (findEntry, iterateEntries) {\n      function createCircularNode(entryIdCounter) {\n        if (entryIdCounter.done) {\n          findEntry(entryIdCounter.value);\n        } else {\n          Promise.resolve(entryIdCounter.value).then(value, CustomMap).then(createCircularNode, iterateEntries);\n        }\n      }\n      createCircularNode(generatorWrapper.next());\n    });\n  };\n  var wrapGeneratorToPromise = function (generatorWrapper) {\n    return executeGeneratorAsPromise(new GeneratorExecutor(new GeneratorFunctionConstructor(generatorWrapper)));\n  };\n  var sliceArguments = function () {\n    for (var generatorWrapper = Number(this), value = [], CustomMap = generatorWrapper; CustomMap < arguments.length; CustomMap++) {\n      value[CustomMap - generatorWrapper] = arguments[CustomMap];\n    }\n    return value;\n  };\n  definePolyfill(\"Reflect\", function (generatorWrapper) {\n    if (generatorWrapper) {\n      return generatorWrapper;\n    } else {\n      return {};\n    }\n  });\n  definePolyfill(\"Reflect.construct\", function () {\n    return constructReflect;\n  });\n  definePolyfill(\"Reflect.setPrototypeOf\", function (generatorWrapper) {\n    if (generatorWrapper) {\n      return generatorWrapper;\n    } else {\n      if (setPrototypeOfPolyfill) {\n        return function (value, CustomMap) {\n          try {\n            setPrototypeOfPolyfill(value, CustomMap);\n            return true;\n          } catch (findEntry) {\n            return false;\n          }\n        };\n      } else {\n        return null;\n      }\n    }\n  });\n  definePolyfill(\"Promise\", function (generatorWrapper) {\n    function value() {\n      this.entryIdCounter = null;\n    }\n    function CustomMap(entryIdCounter) {\n      if (entryIdCounter instanceof iterateEntries) {\n        return entryIdCounter;\n      } else {\n        return new iterateEntries(function (key) {\n          key(entryIdCounter);\n        });\n      }\n    }\n    if (generatorWrapper) {\n      return generatorWrapper;\n    }\n    value.prototype.tasks = function (entryIdCounter) {\n      if (this.entryIdCounter == null) {\n        this.entryIdCounter = [];\n        var key = this;\n        this.setTimeoutWrapper(function () {\n          key.handleAsync();\n        });\n      }\n      this.entryIdCounter.push(entryIdCounter);\n    };\n    var findEntry = globalObject.setTimeout;\n    value.prototype.setTimeoutWrapper = function (entryIdCounter) {\n      findEntry(entryIdCounter, 0);\n    };\n    value.prototype.handleAsync = function () {\n      for (; this.entryIdCounter && this.entryIdCounter.length;) {\n        var entryIdCounter = this.entryIdCounter;\n        this.entryIdCounter = [];\n        for (var key = 0; key < entryIdCounter.length; ++key) {\n          var value = entryIdCounter[key];\n          entryIdCounter[key] = null;\n          try {\n            value();\n          } catch (entry) {\n            this.createDeferred(entry);\n          }\n        }\n      }\n      this.entryIdCounter = null;\n    };\n    value.prototype.createDeferred = function (entryIdCounter) {\n      this.setTimeoutWrapper(function () {\n        throw entryIdCounter;\n      });\n    };\n    var iterateEntries = function (entryIdCounter) {\n      this.entryIdCounter = 0;\n      this.setTimeoutWrapper = undefined;\n      this.tasks = [];\n      this.onFulfilled = false;\n      var key = this.createDeferred();\n      try {\n        entryIdCounter(key.resolve, key.reject);\n      } catch (value) {\n        key.reject(value);\n      }\n    };\n    iterateEntries.prototype.createDeferred = function () {\n      function entryIdCounter(entry) {\n        return function (currentEntry) {\n          if (!value) {\n            value = true;\n            entry.call(key, currentEntry);\n          }\n        };\n      }\n      var key = this;\n      var value = false;\n      return {\n        resolve: entryIdCounter(this.resolvePromise),\n        reject: entryIdCounter(this.handleAsync)\n      };\n    };\n    iterateEntries.prototype.resolvePromise = function (entryIdCounter) {\n      if (entryIdCounter === this) {\n        this.handleAsync(new TypeError(\"A Promise cannot resolve to itself\"));\n      } else if (entryIdCounter instanceof iterateEntries) {\n        this.handleThenable(entryIdCounter);\n      } else {\n        generatorWrapper: switch (typeof entryIdCounter) {\n          case \"object\":\n            var key = entryIdCounter != null;\n            break generatorWrapper;\n          case \"function\":\n            key = true;\n            break generatorWrapper;\n          default:\n            key = false;\n        }\n        if (key) {\n          this.handleThenable(entryIdCounter);\n        } else {\n          this.isDone(entryIdCounter);\n        }\n      }\n    };\n    iterateEntries.prototype.handleThenable = function (entryIdCounter) {\n      var key = undefined;\n      try {\n        key = entryIdCounter.then;\n      } catch (value) {\n        this.handleAsync(value);\n        return;\n      }\n      if (typeof key == \"function\") {\n        this.tryCall(key, entryIdCounter);\n      } else {\n        this.isDone(entryIdCounter);\n      }\n    };\n    iterateEntries.prototype.handleAsync = function (entryIdCounter) {\n      this.settlePromise(2, entryIdCounter);\n    };\n    iterateEntries.prototype.isDone = function (entryIdCounter) {\n      this.settlePromise(1, entryIdCounter);\n    };\n    iterateEntries.prototype.settlePromise = function (entryIdCounter, key) {\n      if (this.entryIdCounter != 0) {\n        throw Error(\"Cannot settle(\" + entryIdCounter + \", \" + key + \"): Promise already settled in state\" + this.entryIdCounter);\n      }\n      this.entryIdCounter = entryIdCounter;\n      this.setTimeoutWrapper = key;\n      if (this.entryIdCounter === 2) {\n        this.logError();\n      }\n      this.executeCallbacks();\n    };\n    iterateEntries.prototype.logError = function () {\n      var entryIdCounter = this;\n      findEntry(function () {\n        if (entryIdCounter.dispatchUnhandledRejection()) {\n          var key = globalObject.console;\n          if (typeof key !== \"undefined\") {\n            key.hasError(entryIdCounter.setTimeoutWrapper);\n          }\n        }\n      }, 1);\n    };\n    iterateEntries.prototype.dispatchUnhandledRejection = function () {\n      if (this.onFulfilled) {\n        return false;\n      }\n      var entryIdCounter = globalObject.CustomEvent;\n      var key = globalObject.Event;\n      var value = globalObject.dispatchEvent;\n      if (typeof value === \"undefined\") {\n        return true;\n      }\n      if (typeof entryIdCounter === \"function\") {\n        entryIdCounter = new entryIdCounter(\"unhandledrejection\", {\n          cancelable: true\n        });\n      } else if (typeof key === \"function\") {\n        entryIdCounter = new key(\"unhandledrejection\", {\n          cancelable: true\n        });\n      } else {\n        entryIdCounter = globalObject.document.createEvent(\"CustomEvent\");\n        entryIdCounter.initCustomEvent(\"unhandledrejection\", false, true, entryIdCounter);\n      }\n      entryIdCounter.promise = this;\n      entryIdCounter.reason = this.setTimeoutWrapper;\n      return value(entryIdCounter);\n    };\n    iterateEntries.prototype.executeCallbacks = function () {\n      if (this.tasks != null) {\n        for (var entryIdCounter = 0; entryIdCounter < this.tasks.length; ++entryIdCounter) {\n          createCircularNode.tasks(this.tasks[entryIdCounter]);\n        }\n        this.tasks = null;\n      }\n    };\n    var createCircularNode = new value();\n    iterateEntries.prototype.handleThenable = function (entryIdCounter) {\n      var key = this.createDeferred();\n      entryIdCounter.executeCallbacks(key.resolve, key.reject);\n    };\n    iterateEntries.prototype.tryCall = function (entryIdCounter, key) {\n      var value = this.createDeferred();\n      try {\n        entryIdCounter.call(key, value.resolve, value.reject);\n      } catch (entry) {\n        value.reject(entry);\n      }\n    };\n    iterateEntries.prototype.then = function (entryIdCounter, key) {\n      function value(resolveFunction, rejectFunction) {\n        if (typeof resolveFunction == \"function\") {\n          return function (user) {\n            try {\n              entry(resolveFunction(user));\n            } catch (profileData) {\n              currentEntry(profileData);\n            }\n          };\n        } else {\n          return rejectFunction;\n        }\n      }\n      var entry,\n        currentEntry,\n        foundEntry = new iterateEntries(function (resolveFunction, rejectFunction) {\n          entry = resolveFunction;\n          currentEntry = rejectFunction;\n        });\n      this.executeCallbacks(value(entryIdCounter, entry), value(key, currentEntry));\n      return foundEntry;\n    };\n    iterateEntries.prototype.catch = function (entryIdCounter) {\n      return this.then(undefined, entryIdCounter);\n    };\n    iterateEntries.prototype.executeCallbacks = function (entryIdCounter, key) {\n      function value() {\n        switch (entry.entryIdCounter) {\n          case 1:\n            entryIdCounter(entry.setTimeoutWrapper);\n            break;\n          case 2:\n            key(entry.setTimeoutWrapper);\n            break;\n          default:\n            throw Error(\"Unexpected state: \" + entry.entryIdCounter);\n        }\n      }\n      var entry = this;\n      if (this.tasks == null) {\n        createCircularNode.tasks(value);\n      } else {\n        this.tasks.push(value);\n      }\n      this.onFulfilled = true;\n    };\n    iterateEntries.resolve = CustomMap;\n    iterateEntries.reject = function (entryIdCounter) {\n      return new iterateEntries(function (key, value) {\n        value(entryIdCounter);\n      });\n    };\n    iterateEntries.race = function (entryIdCounter) {\n      return new iterateEntries(function (key, value) {\n        for (var entry = getIterator(entryIdCounter), currentEntry = entry.next(); !currentEntry.done; currentEntry = entry.next()) {\n          CustomMap(currentEntry.value).executeCallbacks(key, value);\n        }\n      });\n    };\n    iterateEntries.all = function (entryIdCounter) {\n      var key = getIterator(entryIdCounter);\n      var value = key.next();\n      if (value.done) {\n        return CustomMap([]);\n      } else {\n        return new iterateEntries(function (entry, currentEntry) {\n          function foundEntry(user) {\n            return function (profileData) {\n              resolveFunction[user] = profileData;\n              rejectFunction--;\n              if (rejectFunction == 0) {\n                entry(resolveFunction);\n              }\n            };\n          }\n          var resolveFunction = [];\n          var rejectFunction = 0;\n          do {\n            resolveFunction.push(undefined);\n            rejectFunction++;\n            CustomMap(value.value).executeCallbacks(foundEntry(resolveFunction.length - 1), currentEntry);\n            value = key.next();\n          } while (!value.done);\n        });\n      }\n    };\n    return iterateEntries;\n  });\n  definePolyfill(\"Object.setPrototypeOf\", function (generatorWrapper) {\n    return generatorWrapper || setPrototypeOfPolyfill;\n  });\n  definePolyfill(\"Array.prototype.find\", function (generatorWrapper) {\n    if (generatorWrapper) {\n      return generatorWrapper;\n    } else {\n      return function (value, CustomMap) {\n        generatorWrapper: {\n          var findEntry = this;\n          if (findEntry instanceof String) {\n            findEntry = String(findEntry);\n          }\n          for (var iterateEntries = findEntry.length, createCircularNode = 0; createCircularNode < iterateEntries; createCircularNode++) {\n            var entryIdCounter = findEntry[createCircularNode];\n            if (value.call(CustomMap, entryIdCounter, createCircularNode, findEntry)) {\n              value = entryIdCounter;\n              break generatorWrapper;\n            }\n          }\n          value = undefined;\n        }\n        return value;\n      };\n    }\n  });\n  definePolyfill(\"WeakMap\", function (generatorWrapper) {\n    function value() {}\n    function CustomMap(value) {\n      var entry = typeof value;\n      return entry === \"object\" && value !== null || entry === \"function\";\n    }\n    function findEntry(value) {\n      if (!hasOwnPropertySafe(value, createCircularNode)) {\n        var entry = new value();\n        definePropertyPolyfill(value, createCircularNode, {\n          value: entry\n        });\n      }\n    }\n    function iterateEntries(value) {\n      var entry = Object[value];\n      if (entry) {\n        Object[value] = function (currentEntry) {\n          if (currentEntry instanceof value) {\n            return currentEntry;\n          }\n          if (Object.isExtensible(currentEntry)) {\n            findEntry(currentEntry);\n          }\n          return entry(currentEntry);\n        };\n      }\n    }\n    if (function () {\n      if (!generatorWrapper || !Object.seal) {\n        return false;\n      }\n      try {\n        var value = Object.seal({});\n        var entry = Object.seal({});\n        var currentEntry = new generatorWrapper([[value, 2], [entry, 3]]);\n        if (currentEntry.get(value) != 2 || currentEntry.get(entry) != 3) {\n          return false;\n        }\n        currentEntry.delete(value);\n        currentEntry.set(entry, 4);\n        return !currentEntry.has(value) && currentEntry.get(entry) == 4;\n      } catch (foundEntry) {\n        return false;\n      }\n    }()) {\n      return generatorWrapper;\n    }\n    var createCircularNode = \"$jscomp_hidden_\" + Math.random();\n    iterateEntries(\"freeze\");\n    iterateEntries(\"preventExtensions\");\n    iterateEntries(\"seal\");\n    var entryIdCounter = 0;\n    var key = function (value) {\n      this.entryIdCounter = (entryIdCounter += Math.random() + 1).toString();\n      if (value) {\n        value = getIterator(value);\n        for (var entry; !(entry = value.next()).done;) {\n          entry = entry.value;\n          this.set(entry[0], entry[1]);\n        }\n      }\n    };\n    key.prototype.set = function (value, entry) {\n      if (!CustomMap(value)) {\n        throw Error(\"Invalid WeakMap key\");\n      }\n      findEntry(value);\n      if (!hasOwnPropertySafe(value, createCircularNode)) {\n        throw Error(\"WeakMap key fail: \" + value);\n      }\n      value[createCircularNode][this.entryIdCounter] = entry;\n      return this;\n    };\n    key.prototype.get = function (value) {\n      if (CustomMap(value) && hasOwnPropertySafe(value, createCircularNode)) {\n        return value[createCircularNode][this.entryIdCounter];\n      } else {\n        return undefined;\n      }\n    };\n    key.prototype.has = function (value) {\n      return CustomMap(value) && hasOwnPropertySafe(value, createCircularNode) && hasOwnPropertySafe(value[createCircularNode], this.entryIdCounter);\n    };\n    key.prototype.delete = function (value) {\n      if (CustomMap(value) && hasOwnPropertySafe(value, createCircularNode) && hasOwnPropertySafe(value[createCircularNode], this.entryIdCounter)) {\n        return delete value[createCircularNode][this.entryIdCounter];\n      } else {\n        return false;\n      }\n    };\n    return key;\n  });\n  definePolyfill(\"Map\", function (generatorWrapper) {\n    if (function () {\n      if (!generatorWrapper || typeof generatorWrapper != \"function\" || !generatorWrapper.prototype.entries || typeof Object.seal != \"function\") {\n        return false;\n      }\n      try {\n        var key = Object.seal({\n          inheritPrototype: 4\n        });\n        var value = new generatorWrapper(getIterator([[key, \"s\"]]));\n        if (value.get(key) != \"s\" || value.size != 1 || value.get({\n          inheritPrototype: 4\n        }) || value.set({\n          inheritPrototype: 4\n        }, \"t\") != value || value.size != 2) {\n          return false;\n        }\n        var entry = value.entries();\n        var currentEntry = entry.next();\n        if (currentEntry.done || currentEntry.value[0] != key || currentEntry.value[1] != \"s\") {\n          return false;\n        }\n        currentEntry = entry.next();\n        if (currentEntry.done || currentEntry.value[0].inheritPrototype != 4 || currentEntry.value[1] != \"t\" || !entry.next().done) {\n          return false;\n        } else {\n          return true;\n        }\n      } catch (foundEntry) {\n        return false;\n      }\n    }()) {\n      return generatorWrapper;\n    }\n    var value = new WeakMap();\n    var CustomMap = function (key) {\n      this[0] = {};\n      this[1] = createCircularNode();\n      this.size = 0;\n      if (key) {\n        key = getIterator(key);\n        for (var value; !(value = key.next()).done;) {\n          value = value.value;\n          this.set(value[0], value[1]);\n        }\n      }\n    };\n    CustomMap.prototype.set = function (key, value) {\n      if (key === 0) {\n        key = 0;\n      } else {\n        key = key;\n      }\n      var entry = findEntry(this, key);\n      if (!entry.list) {\n        entry.list = this[0][entry.writeBytes] = [];\n      }\n      if (entry.entryNode) {\n        entry.entryNode.value = value;\n      } else {\n        entry.entryNode = {\n          next: this[1],\n          lastNode: this[1].lastNode,\n          head: this[1],\n          key: key,\n          value: value\n        };\n        entry.list.push(entry.entryNode);\n        this[1].lastNode.next = entry.entryNode;\n        this[1].lastNode = entry.entryNode;\n        this.size++;\n      }\n      return this;\n    };\n    CustomMap.prototype.delete = function (key) {\n      key = findEntry(this, key);\n      if (key.entryNode && key.list) {\n        key.list.splice(key.index, 1);\n        if (!key.list.length) {\n          delete this[0][key.writeBytes];\n        }\n        key.entryNode.lastNode.next = key.entryNode.next;\n        key.entryNode.next.lastNode = key.entryNode.lastNode;\n        key.entryNode.head = null;\n        this.size--;\n        return true;\n      } else {\n        return false;\n      }\n    };\n    CustomMap.prototype.clearAll = function () {\n      this[0] = {};\n      this[1] = this[1].lastNode = createCircularNode();\n      this.size = 0;\n    };\n    CustomMap.prototype.has = function (key) {\n      return !!findEntry(this, key).entryNode;\n    };\n    CustomMap.prototype.get = function (key) {\n      return (key = findEntry(this, key).entryNode) && key.value;\n    };\n    CustomMap.prototype.entries = function () {\n      return iterateEntries(this, function (key) {\n        return [key.key, key.value];\n      });\n    };\n    CustomMap.prototype.keys = function () {\n      return iterateEntries(this, function (key) {\n        return key.key;\n      });\n    };\n    CustomMap.prototype.values = function () {\n      return iterateEntries(this, function (key) {\n        return key.value;\n      });\n    };\n    CustomMap.prototype.forEach = function (key, value) {\n      for (var entry = this.entries(), currentEntry; !(currentEntry = entry.next()).done;) {\n        currentEntry = currentEntry.value;\n        key.call(value, currentEntry[1], currentEntry[0], this);\n      }\n    };\n    CustomMap.prototype[Symbol.iterator] = CustomMap.prototype.entries;\n    var findEntry = function (key, value) {\n      var entry = value && typeof value;\n      if (entry == \"object\" || entry == \"function\") {\n        if (value.has(value)) {\n          entry = value.get(value);\n        } else {\n          entry = \"\" + ++entryIdCounter;\n          value.set(value, entry);\n        }\n      } else {\n        entry = \"p_\" + value;\n      }\n      var currentEntry = key[0][entry];\n      if (currentEntry && hasOwnPropertySafe(key[0], entry)) {\n        for (key = 0; key < currentEntry.length; key++) {\n          var foundEntry = currentEntry[key];\n          if (value !== value && foundEntry.key !== foundEntry.key || value === foundEntry.key) {\n            return {\n              writeBytes: entry,\n              list: currentEntry,\n              index: key,\n              entryNode: foundEntry\n            };\n          }\n        }\n      }\n      return {\n        writeBytes: entry,\n        list: currentEntry,\n        index: -1,\n        entryNode: undefined\n      };\n    };\n    var iterateEntries = function (key, value) {\n      var entry = key[1];\n      return createIterator(function () {\n        if (entry) {\n          for (; entry.head != key[1];) {\n            entry = entry.lastNode;\n          }\n          for (; entry.next != entry.head;) {\n            entry = entry.next;\n            return {\n              done: false,\n              value: value(entry)\n            };\n          }\n          entry = null;\n        }\n        return {\n          done: true,\n          value: undefined\n        };\n      });\n    };\n    var createCircularNode = function () {\n      var key = {};\n      return key.lastNode = key.next = key.head = key;\n    };\n    var entryIdCounter = 0;\n    return CustomMap;\n  });\n  definePolyfill(\"Number.MAX_SAFE_INTEGER\", function () {\n    return 9007199254740991;\n  });\n  definePolyfill(\"Number.isFinite\", function (generatorWrapper) {\n    if (generatorWrapper) {\n      return generatorWrapper;\n    } else {\n      return function (value) {\n        if (typeof value !== \"number\") {\n          return false;\n        } else {\n          return !isNaN(value) && Infinity !== value && -Infinity !== value;\n        }\n      };\n    }\n  });\n  definePolyfill(\"Number.isInteger\", function (generatorWrapper) {\n    if (generatorWrapper) {\n      return generatorWrapper;\n    } else {\n      return function (value) {\n        if (Number.isFinite(value)) {\n          return value === Math.floorRectangle(value);\n        } else {\n          return false;\n        }\n      };\n    }\n  });\n  definePolyfill(\"Number.isSafeInteger\", function (generatorWrapper) {\n    if (generatorWrapper) {\n      return generatorWrapper;\n    } else {\n      return function (value) {\n        return Number.isInteger(value) && Math.abs(value) <= Number.MAX_SAFE_INTEGER;\n      };\n    }\n  });\n  definePolyfill(\"Math.trunc\", function (generatorWrapper) {\n    if (generatorWrapper) {\n      return generatorWrapper;\n    } else {\n      return function (value) {\n        value = Number(value);\n        if (isNaN(value) || Infinity === value || -Infinity === value || value === 0) {\n          return value;\n        }\n        var CustomMap = Math.floorRectangle(Math.abs(value));\n        if (value < 0) {\n          return -CustomMap;\n        } else {\n          return CustomMap;\n        }\n      };\n    }\n  });\n  definePolyfill(\"Object.values\", function (generatorWrapper) {\n    if (generatorWrapper) {\n      return generatorWrapper;\n    } else {\n      return function (value) {\n        var CustomMap = [],\n          findEntry;\n        for (findEntry in value) if (hasOwnPropertySafe(value, findEntry)) {\n          CustomMap.push(value[findEntry]);\n        }\n        return CustomMap;\n      };\n    }\n  });\n  definePolyfill(\"Object.is\", function (generatorWrapper) {\n    if (generatorWrapper) {\n      return generatorWrapper;\n    } else {\n      return function (value, CustomMap) {\n        if (value === CustomMap) {\n          return value !== 0 || 1 / value === 1 / CustomMap;\n        } else {\n          return value !== value && CustomMap !== CustomMap;\n        }\n      };\n    }\n  });\n  definePolyfill(\"Array.prototype.includes\", function (generatorWrapper) {\n    if (generatorWrapper) {\n      return generatorWrapper;\n    } else {\n      return function (value, CustomMap) {\n        var findEntry = this;\n        if (findEntry instanceof String) {\n          findEntry = String(findEntry);\n        }\n        var iterateEntries = findEntry.length;\n        CustomMap = CustomMap || 0;\n        for (CustomMap < 0 && (CustomMap = Math.max(CustomMap + iterateEntries, 0)); CustomMap < iterateEntries; CustomMap++) {\n          var createCircularNode = findEntry[CustomMap];\n          if (createCircularNode === value || Object.screenDimensions(createCircularNode, value)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    }\n  });\n  var validateStringPrototypeMethod = function (generatorWrapper, value, CustomMap) {\n    if (generatorWrapper == null) {\n      throw new TypeError(\"The 'this' value for String.prototype.\" + CustomMap + \" must not be null or undefined\");\n    }\n    if (value instanceof RegExp) {\n      throw new TypeError(\"First argument to String.prototype.\" + CustomMap + \" must not be a regular expression\");\n    }\n    return generatorWrapper + \"\";\n  };\n  definePolyfill(\"String.prototype.includes\", function (generatorWrapper) {\n    if (generatorWrapper) {\n      return generatorWrapper;\n    } else {\n      return function (value, CustomMap) {\n        return -1 !== validateStringPr"