"atorWrapper.length, findEntry = typeof generatorWrapper === \"string\" ? generatorWrapper.split(\"\") : generatorWrapper, iterateEntries = 0; iterateEntries < CustomMap; iterateEntries++) {\n      if (iterateEntries in findEntry && value.call(undefined, findEntry[iterateEntries], iterateEntries, generatorWrapper)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  function findElement(generatorWrapper, value) {\n    value = findElementIndex(generatorWrapper, value);\n    if (value < 0) {\n      return null;\n    } else {\n      if (typeof generatorWrapper === \"string\") {\n        return generatorWrapper.charAt(value);\n      } else {\n        return generatorWrapper[value];\n      }\n    }\n  }\n  function findElementIndex(generatorWrapper, value) {\n    for (var CustomMap = generatorWrapper.length, findEntry = typeof generatorWrapper === \"string\" ? generatorWrapper.split(\"\") : generatorWrapper, iterateEntries = 0; iterateEntries < CustomMap; iterateEntries++) {\n      if (iterateEntries in findEntry && value.call(undefined, findEntry[iterateEntries], iterateEntries, generatorWrapper)) {\n        return iterateEntries;\n      }\n    }\n    return -1;\n  }\n  function findLastElement(generatorWrapper, value) {\n    value = findLastElementIndex(generatorWrapper, value);\n    if (value < 0) {\n      return null;\n    } else {\n      if (typeof generatorWrapper === \"string\") {\n        return generatorWrapper.charAt(value);\n      } else {\n        return generatorWrapper[value];\n      }\n    }\n  }\n  function findLastElementIndex(generatorWrapper, value) {\n    for (var CustomMap = typeof generatorWrapper === \"string\" ? generatorWrapper.split(\"\") : generatorWrapper, findEntry = generatorWrapper.length - 1; findEntry >= 0; findEntry--) {\n      if (findEntry in CustomMap && value.call(undefined, CustomMap[findEntry], findEntry, generatorWrapper)) {\n        return findEntry;\n      }\n    }\n    return -1;\n  }\n  function containsElement(generatorWrapper, value) {\n    return indexOfChar(generatorWrapper, value) >= 0;\n  }\n  function removeElement(generatorWrapper, value) {\n    value = indexOfChar(generatorWrapper, value);\n    var CustomMap;\n    if (CustomMap = value >= 0) {\n      removeElementAtIndex(generatorWrapper, value);\n    }\n    return CustomMap;\n  }\n  function removeElementAtIndex(generatorWrapper, value) {\n    return Array.prototype.splice.call(generatorWrapper, value, 1).length == 1;\n  }\n  function removeElementsByCondition(generatorWrapper, value) {\n    var CustomMap = 0;\n    forEachElementReverse(generatorWrapper, function (findEntry, iterateEntries) {\n      if (value.call(undefined, findEntry, iterateEntries, generatorWrapper) && removeElementAtIndex(generatorWrapper, iterateEntries)) {\n        CustomMap++;\n      }\n    });\n  }\n  function concatArrays(generatorWrapper) {\n    return Array.prototype.concat.apply([], arguments);\n  }\n  function copyArray(generatorWrapper) {\n    var value = generatorWrapper.length;\n    if (value > 0) {\n      for (var CustomMap = Array(value), findEntry = 0; findEntry < value; findEntry++) {\n        CustomMap[findEntry] = generatorWrapper[findEntry];\n      }\n      return CustomMap;\n    }\n    return [];\n  }\n  function uniqueElements(generatorWrapper) {\n    for (var value = 0, CustomMap = 0, findEntry = {}; CustomMap < generatorWrapper.length;) {\n      var iterateEntries = generatorWrapper[CustomMap++];\n      var createCircularNode = isObjectOrFunction(iterateEntries) ? \"o\" + getUniqueId(iterateEntries) : (typeof iterateEntries).charAt(0) + iterateEntries;\n      if (!Object.prototype.hasOwnProperty.call(findEntry, createCircularNode)) {\n        findEntry[createCircularNode] = true;\n        generatorWrapper[value++] = iterateEntries;\n      }\n    }\n    generatorWrapper.length = value;\n  }\n  function sortArray(generatorWrapper, value) {\n    generatorWrapper.sort(value || defaultSort);\n  }\n  function defaultSort(generatorWrapper, value) {\n    if (generatorWrapper > value) {\n      return 1;\n    } else {\n      if (generatorWrapper < value) {\n        return -1;\n      } else {\n        return 0;\n      }\n    }\n  }\n  function createEmptyStringsArray(generatorWrapper) {\n    for (var value = [], CustomMap = 0; CustomMap < generatorWrapper; CustomMap++) {\n      value[CustomMap] = \"\";\n    }\n    return value;\n  }\n  var noopFunction = function (generatorWrapper) {\n    noopFunction[\" \"](generatorWrapper);\n    return generatorWrapper;\n  };\n  noopFunction[\" \"] = function () {};\n  var tryNoopFunction = function (generatorWrapper, value) {\n    try {\n      noopFunction(generatorWrapper[value]);\n      return true;\n    } catch (CustomMap) {}\n    return false;\n  };\n  var getCachedValue = function (generatorWrapper) {\n    var value = browserFeatures;\n    if (Object.prototype.hasOwnProperty.call(value, 8)) {\n      return value[8];\n    } else {\n      return value[8] = generatorWrapper(8);\n    }\n  };\n  var userAgentVersion;\n  var isOpera = isOperaBrowser();\n  var isIE = isInternetExplorer();\n  var isEdge = handleAsync(\"Edge\");\n  var isGecko = handleAsync(\"Gecko\") && !(includesIgnoreCase(getUserAgent(), \"WebKit\") && !handleAsync(\"Edge\")) && !(handleAsync(\"Trident\") || handleAsync(\"MSIE\")) && !handleAsync(\"Edge\");\n  var isWebKit = includesIgnoreCase(getUserAgent(), \"WebKit\") && !handleAsync(\"Edge\");\n  var isMacOS = isMacOS();\n  var isAndroid = isAndroid();\n  var isIphone = isIphone();\n  var isIpad = handleAsync(\"iPad\");\n  var isIpod = handleAsync(\"iPod\");\n  var isIphoneIpadIpod = isIphone() || handleAsync(\"iPad\") || handleAsync(\"iPod\");\n  generatorWrapper: {\n    var browserVersion = \"\";\n    var executeCallbacks = function () {\n      var generatorWrapper = getUserAgent();\n      if (isGecko) {\n        return /rv:([^\\);]+)(\\)|;)/.exec(generatorWrapper);\n      }\n      if (isEdge) {\n        return /Edge\\/([\\d\\.]+)/.exec(generatorWrapper);\n      }\n      if (isIE) {\n        return /\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/.exec(generatorWrapper);\n      }\n      if (isWebKit) {\n        return /WebKit\\/(\\S+)/.exec(generatorWrapper);\n      }\n      if (isOpera) {\n        return /(?:Version)[ \\/]?(\\S+)/.exec(generatorWrapper);\n      }\n    }();\n    if (executeCallbacks) {\n      if (executeCallbacks) {\n        browserVersion = executeCallbacks[1];\n      } else {\n        browserVersion = \"\";\n      }\n    }\n    if (isIE) {\n      var documentMode,\n        currentDocument = globalScope.document;\n      if (currentDocument) {\n        documentMode = currentDocument.documentMode;\n      } else {\n        documentMode = undefined;\n      }\n      if (documentMode != null && documentMode > parseFloat(browserVersion)) {\n        userAgentVersion = String(documentMode);\n        break generatorWrapper;\n      }\n    }\n    userAgentVersion = browserVersion;\n  }\n  var finalBrowserVersion = userAgentVersion;\n  var browserFeatures = {};\n  var supportsHtml5 = function () {\n    return getCachedValue(function () {\n      return compareVersions(finalBrowserVersion, 8) >= 0;\n    });\n  };\n  var isAndroidBrowser = isFirefox();\n  var isAndroidNonChrome = handleAsync(\"Android\") && !(isChromiumBased() || isFirefox() || isOperaBrowser() || handleAsync(\"Silk\"));\n  var isIos = isChromiumBased();\n  isSafari();\n  var base64AlphabetVariants = {};\n  var base64AlphabetIndex = null;\n  var base64Encode = function (generatorWrapper, value) {\n    if (undefined === value) {\n      value = 0;\n    }\n    initializeBase64Encoding();\n    value = base64AlphabetVariants[value];\n    for (var CustomMap = Array(Math.floorRectangle(generatorWrapper.length / 3)), findEntry = value[64] || \"\", iterateEntries = 0, createCircularNode = 0; iterateEntries < generatorWrapper.length - 2; iterateEntries += 3) {\n      var entryIdCounter = generatorWrapper[iterateEntries];\n      var key = generatorWrapper[iterateEntries + 1];\n      var value = generatorWrapper[iterateEntries + 2];\n      var entry = value[entryIdCounter >> 2];\n      entryIdCounter = value[(entryIdCounter & 3) << 4 | key >> 4];\n      key = value[(key & 15) << 2 | value >> 6];\n      value = value[value & 63];\n      CustomMap[createCircularNode++] = \"\" + entry + entryIdCounter + key + value;\n    }\n    entry = 0;\n    value = findEntry;\n    switch (generatorWrapper.length - iterateEntries) {\n      case 2:\n        entry = generatorWrapper[iterateEntries + 1];\n        value = value[(entry & 15) << 2] || findEntry;\n      case 1:\n        generatorWrapper = generatorWrapper[iterateEntries];\n        CustomMap[createCircularNode] = \"\" + value[generatorWrapper >> 2] + value[(generatorWrapper & 3) << 4 | entry >> 4] + value + findEntry;\n    }\n    return CustomMap.join(\"\");\n  };\n  var getBase64EncodedArray = function (generatorWrapper) {\n    var value = [];\n    decodeBase64(generatorWrapper, function (CustomMap) {\n      value.push(CustomMap);\n    });\n    return value;\n  };\n  var decodeBase64 = function (generatorWrapper, value) {\n    function CustomMap(value) {\n      for (; findEntry < generatorWrapper.length;) {\n        var entry = generatorWrapper.charAt(findEntry++);\n        var currentEntry = base64AlphabetIndex[entry];\n        if (currentEntry != null) {\n          return currentEntry;\n        }\n        if (!isEmptyOrWhitespace(entry)) {\n          throw Error(\"Unknown base64 encoding at char: \" + entry);\n        }\n      }\n      return value;\n    }\n    initializeBase64Encoding();\n    for (var findEntry = 0;;) {\n      var iterateEntries = CustomMap(-1);\n      var createCircularNode = CustomMap(0);\n      var entryIdCounter = CustomMap(64);\n      var key = CustomMap(64);\n      if (key === 64 && -1 === iterateEntries) {\n        break;\n      }\n      value(iterateEntries << 2 | createCircularNode >> 4);\n      if (entryIdCounter != 64) {\n        value(createCircularNode << 4 & 240 | entryIdCounter >> 2);\n        if (key != 64) {\n          value(entryIdCounter << 6 & 192 | key);\n        }\n      }\n    }\n  };\n  var initializeBase64Encoding = function () {\n    if (!base64AlphabetIndex) {\n      base64AlphabetIndex = {};\n      for (var generatorWrapper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\".split(\"\"), value = [\"+/=\", \"+/\", \"-_=\", \"-_.\", \"-_\"], CustomMap = 0; CustomMap < 5; CustomMap++) {\n        var findEntry = generatorWrapper.concat(value[CustomMap].split(\"\"));\n        base64AlphabetVariants[CustomMap] = findEntry;\n        for (var iterateEntries = 0; iterateEntries < findEntry.length; iterateEntries++) {\n          var createCircularNode = findEntry[iterateEntries];\n          if (undefined === base64AlphabetIndex[createCircularNode]) {\n            base64AlphabetIndex[createCircularNode] = iterateEntries;\n          }\n        }\n      }\n    }\n  };\n  var supportsUint8Array = typeof Uint8Array !== \"undefined\";\n  var supportsBtoa = !isIE && typeof btoa === \"function\";\n  function supportsBigInt() {\n    return typeof BigInt === \"function\";\n  }\n  var unusedVar1;\n  var lowOrderInteger = 0;\n  var highOrderInteger = 0;\n  function calculateIntegers(generatorWrapper) {\n    var value = generatorWrapper < 0;\n    generatorWrapper = Math.abs(generatorWrapper);\n    var CustomMap = generatorWrapper >>> 0;\n    generatorWrapper = Math.floorRectangle((generatorWrapper - CustomMap) / 4294967296);\n    if (value) {\n      CustomMap = getIterator(invertAndIncrement(CustomMap, generatorWrapper));\n      value = CustomMap.next().value;\n      generatorWrapper = CustomMap.next().value;\n      CustomMap = value;\n    }\n    lowOrderInteger = CustomMap >>> 0;\n    highOrderInteger = generatorWrapper >>> 0;\n  }\n  function formatLongNumber(generatorWrapper, value) {\n    value >>>= 0;\n    generatorWrapper >>>= 0;\n    if (value <= 2097151) {\n      var CustomMap = \"\" + (4294967296 * value + generatorWrapper);\n    } else if (supportsBigInt()) {\n      CustomMap = \"\" + (BigInt(value) << BigInt(32) | BigInt(generatorWrapper));\n    } else {\n      CustomMap = (generatorWrapper >>> 24 | value << 8) & 16777215;\n      value = value >> 16 & 65535;\n      generatorWrapper = (generatorWrapper & 16777215) + 6777216 * CustomMap + 6710656 * value;\n      CustomMap += 8147497 * value;\n      value *= 2;\n      if (generatorWrapper >= 10000000) {\n        CustomMap += Math.floorRectangle(generatorWrapper / 10000000);\n        generatorWrapper %= 10000000;\n      }\n      if (CustomMap >= 10000000) {\n        value += Math.floorRectangle(CustomMap / 10000000);\n        CustomMap %= 10000000;\n      }\n      CustomMap = value + padNumber(CustomMap) + padNumber(generatorWrapper);\n    }\n    return CustomMap;\n  }\n  function padNumber(generatorWrapper) {\n    generatorWrapper = String(generatorWrapper);\n    return \"0000000\".slice(generatorWrapper.length) + generatorWrapper;\n  }\n  function getFormattedNumber() {\n    var generatorWrapper = lowOrderInteger;\n    var value = highOrderInteger;\n    if (value & 2147483648) {\n      if (supportsBigInt()) {\n        generatorWrapper = \"\" + (BigInt(value | 0) << BigInt(32) | BigInt(generatorWrapper >>> 0));\n      } else {\n        value = getIterator(invertAndIncrement(generatorWrapper, value));\n        generatorWrapper = value.next().value;\n        value = value.next().value;\n        generatorWrapper = \"-\" + formatLongNumber(generatorWrapper, value);\n      }\n    } else {\n      generatorWrapper = formatLongNumber(generatorWrapper, value);\n    }\n    return generatorWrapper;\n  }\n  function parseAndSetBigIntegers(generatorWrapper) {\n    if (generatorWrapper.length < 16) {\n      calculateIntegers(Number(generatorWrapper));\n    } else if (supportsBigInt()) {\n      generatorWrapper = BigInt(generatorWrapper);\n      lowOrderInteger = Number(generatorWrapper & BigInt(4294967295)) >>> 0;\n      highOrderInteger = Number(generatorWrapper >> BigInt(32) & BigInt(4294967295));\n    } else {\n      var value = +(generatorWrapper[0] === \"-\");\n      highOrderInteger = lowOrderInteger = 0;\n      findEntry = iterateEntries;\n      for (var CustomMap = generatorWrapper.length, findEntry = 0 + value, iterateEntries = (CustomMap - value) % 6 + value; iterateEntries <= CustomMap; iterateEntries += 6) {\n        findEntry = Number(generatorWrapper.slice(findEntry, iterateEntries));\n        highOrderInteger *= 1000000;\n        lowOrderInteger = 1000000 * lowOrderInteger + findEntry;\n        if (lowOrderInteger >= 4294967296) {\n          highOrderInteger += Math.trunc(lowOrderInteger / 4294967296);\n          highOrderInteger >>>= 0;\n          lowOrderInteger >>>= 0;\n        }\n      }\n      if (value) {\n        value = getIterator(invertAndIncrement(lowOrderInteger, highOrderInteger));\n        generatorWrapper = value.next().value;\n        value = value.next().value;\n        lowOrderInteger = generatorWrapper;\n        highOrderInteger = value;\n      }\n    }\n  }\n  function invertAndIncrement(generatorWrapper, value) {\n    value = ~value;\n    if (generatorWrapper) {\n      generatorWrapper = ~generatorWrapper + 1;\n    } else {\n      value += 1;\n    }\n    return [generatorWrapper, value];\n  }\n  var defaultUnsigned64, defaultSigned64;\n  var Unsigned64 = function (generatorWrapper, value) {\n    this.tasks = generatorWrapper >>> 0;\n    this.entryIdCounter = value >>> 0;\n  };\n  var createUnsigned64 = function (generatorWrapper) {\n    if (!generatorWrapper) {\n      return defaultUnsigned64 || (defaultUnsigned64 = new Unsigned64(0, 0));\n    }\n    if (!/^\\d+$/.test(generatorWrapper)) {\n      return null;\n    }\n    parseAndSetBigIntegers(generatorWrapper);\n    return new Unsigned64(lowOrderInteger, highOrderInteger);\n  };\n  var Signed64 = function (generatorWrapper, value) {\n    this.tasks = generatorWrapper >>> 0;\n    this.entryIdCounter = value >>> 0;\n  };\n  var createSigned64 = function (generatorWrapper) {\n    if (!generatorWrapper) {\n      return defaultSigned64 || (defaultSigned64 = new Signed64(0, 0));\n    }\n    if (!/^-?\\d+$/.test(generatorWrapper)) {\n      return null;\n    }\n    parseAndSetBigIntegers(generatorWrapper);\n    return new Signed64(lowOrderInteger, highOrderInteger);\n  };\n  var ByteArray = function () {\n    this.entryIdCounter = [];\n  };\n  ByteArray.prototype.length = function () {\n    return this.entryIdCounter.length;\n  };\n  ByteArray.prototype.end = function () {\n    var generatorWrapper = this.entryIdCounter;\n    this.entryIdCounter = [];\n    return generatorWrapper;\n  };\n  var writeVarint32 = function (generatorWrapper, value, CustomMap) {\n    for (; CustomMap > 0 || value > 127;) {\n      generatorWrapper.entryIdCounter.push(value & 127 | 128);\n      value = (value >>> 7 | CustomMap << 25) >>> 0;\n      CustomMap >>>= 7;\n    }\n    generatorWrapper.entryIdCounter.push(value);\n  };\n  var writeVarint = function (generatorWrapper, value) {\n    for (; value > 127;) {\n      generatorWrapper.entryIdCounter.push(value & 127 | 128);\n      value >>>= 7;\n    }\n    generatorWrapper.entryIdCounter.push(value);\n  };\n  var writeVarint64 = function (generatorWrapper, value) {\n    if (value >= 0) {\n      writeVarint(generatorWrapper, value);\n    } else {\n      for (var CustomMap = 0; CustomMap < 9; CustomMap++) {\n        generatorWrapper.entryIdCounter.push(value & 127 | 128);\n        value >>= 7;\n      }\n      generatorWrapper.entryIdCounter.push(1);\n    }\n  };\n  var writeBytes = function (generatorWrapper, value) {\n    generatorWrapper.entryIdCounter.push(value >>> 0 & 255);\n    generatorWrapper.entryIdCounter.push(value >>> 8 & 255);\n    generatorWrapper.entryIdCounter.push(value >>> 16 & 255);\n    generatorWrapper.entryIdCounter.push(value >>> 24 & 255);\n  };\n  var ProtobufWriter = function () {\n    this.setTimeoutWrapper = [];\n    this.tasks = 0;\n    this.entryIdCounter = new ByteArray();\n  };\n  var appendBuffer = function (generatorWrapper, value) {\n    if (value.length !== 0) {\n      generatorWrapper.setTimeoutWrapper.push(value);\n      generatorWrapper.tasks += value.length;\n    }\n  };\n  var finalizeAndAppendBuffer = function (generatorWrapper, value) {\n    writeFieldHeader(generatorWrapper, value, 2);\n    value = generatorWrapper.entryIdCounter.end();\n    appendBuffer(generatorWrapper, value);\n    value.push(generatorWrapper.tasks);\n    return value;\n  };\n  var updateLengthPrefix = function (generatorWrapper, value) {\n    var CustomMap = value.pop();\n    for (CustomMap = generatorWrapper.tasks + generatorWrapper.entryIdCounter.length() - CustomMap; CustomMap > 127;) {\n      value.push(CustomMap & 127 | 128);\n      CustomMap >>>= 7;\n      generatorWrapper.tasks++;\n    }\n    value.push(CustomMap);\n    generatorWrapper.tasks++;\n  };\n  var writeFieldHeader = function (generatorWrapper, value, CustomMap) {\n    writeVarint(generatorWrapper.entryIdCounter, 8 * value + CustomMap);\n  };\n  var writeBytesField = function (generatorWrapper, value, CustomMap) {\n    writeFieldHeader(generatorWrapper, value, 2);\n    writeVarint(generatorWrapper.entryIdCounter, CustomMap.length);\n    appendBuffer(generatorWrapper, generatorWrapper.entryIdCounter.end());\n    appendBuffer(generatorWrapper, CustomMap);\n  };\n  var CustomError = function (generatorWrapper, value) {\n    this.entryIdCounter = generatorWrapper;\n    this.checkIfFrozen = value;\n  };\n  function toArray(generatorWrapper) {\n    return Array.prototype.slice.call(generatorWrapper);\n  }\n  function generateSymbol(generatorWrapper) {\n    if (typeof Symbol === \"function\" && typeof Symbol() === \"symbol\") {\n      return Symbol();\n    } else {\n      return generatorWrapper;\n    }\n  }\n  var uniqueSymbol = generateSymbol();\n  var customProperty1 = generateSymbol(\"0di\");\n  var customProperty2 = generateSymbol(\"2ex\");\n  var customProperty3 = generateSymbol(\"0dg\");\n  var setCustomProperty = uniqueSymbol ? function (generatorWrapper, value) {\n    generatorWrapper[uniqueSymbol] |= value;\n  } : function (generatorWrapper, value) {\n    if (undefined !== generatorWrapper.GeneratorFunctionConstructor) {\n      generatorWrapper.GeneratorFunctionConstructor |= value;\n    } else {\n      Object.defineProperties(generatorWrapper, {\n        GeneratorFunctionConstructor: {\n          value: value,\n          configurable: true,\n          writable: true,\n          enumerable: false\n        }\n      });\n    }\n  };\n  var clearBitFlag = uniqueSymbol ? function (generatorWrapper, value) {\n    generatorWrapper[uniqueSymbol] &= ~value;\n  } : function (generatorWrapper, value) {\n    if (undefined !== generatorWrapper.GeneratorFunctionConstructor) {\n      generatorWrapper.GeneratorFunctionConstructor &= ~value;\n    }\n  };\n  function toggleBitFlag(generatorWrapper, value, CustomMap) {\n    if (CustomMap) {\n      return generatorWrapper | value;\n    } else {\n      return generatorWrapper & ~value;\n    }\n  }\n  var getBitFlags = uniqueSymbol ? function (generatorWrapper) {\n    return generatorWrapper[uniqueSymbol] | 0;\n  } : function (generatorWrapper) {\n    return generatorWrapper.GeneratorFunctionConstructor | 0;\n  };\n  var getRawBitFlags = uniqueSymbol ? function (generatorWrapper) {\n    return generatorWrapper[uniqueSymbol];\n  } : function (generatorWrapper) {\n    return generatorWrapper.GeneratorFunctionConstructor;\n  };\n  var setRawBitFlags = uniqueSymbol ? function (generatorWrapper, value) {\n    generatorWrapper[uniqueSymbol] = value;\n    return generatorWrapper;\n  } : function (generatorWrapper, value) {\n    if (undefined !== generatorWrapper.GeneratorFunctionConstructor) {\n      generatorWrapper.GeneratorFunctionConstructor = value;\n    } else {\n      Object.defineProperties(generatorWrapper, {\n        GeneratorFunctionConstructor: {\n          value: value,\n          configurable: true,\n          writable: true,\n          enumerable: false\n        }\n      });\n    }\n    return generatorWrapper;\n  };\n  function setFlag34(generatorWrapper) {\n    setCustomProperty(generatorWrapper, 34);\n    return generatorWrapper;\n  }\n  function setFlag32(generatorWrapper) {\n    setCustomProperty(generatorWrapper, 32);\n    return generatorWrapper;\n  }\n  function clear14591Flag(generatorWrapper, value) {\n    setRawBitFlags(value, (generatorWrapper | 0) & -14591);\n  }\n  function set34Clear14557Flag(generatorWrapper, value) {\n    setRawBitFlags(value, (generatorWrapper | 34) & -14557);\n  }\n  function get1023Shifted(generatorWrapper) {\n    generatorWrapper = generatorWrapper >> 14 & 1023;\n    if (generatorWrapper === 0) {\n      return 536870912;\n    } else {\n      return generatorWrapper;\n    }\n  }\n  var emptyObject1 = {};\n  var emptyObject2 = {};\n  function isObjectWithId(generatorWrapper) {\n    return !(!generatorWrapper || typeof generatorWrapper !== \"object\" || generatorWrapper.booleanFlagTransformation !== emptyObject2);\n  }\n  function isPlainObject(generatorWrapper) {\n    return generatorWrapper !== null && typeof generatorWrapper === \"object\" && !Array.isArray(generatorWrapper) && generatorWrapper.constructor === Object;\n  }\n  var undefinedVariable1;\n  function undefinedFunction1(generatorWrapper, value, CustomMap) {\n    if (!Array.isArray(generatorWrapper) || generatorWrapper.length) {\n      return false;\n    }\n    var findEntry = getBitFlags(generatorWrapper);\n    if (findEntry & 1) {\n      return true;\n    }\n    if (!(value && (Array.isArray(value) ? value.includes(CustomMap) : value.has(CustomMap)))) {\n      return false;\n    }\n    setRawBitFlags(generatorWrapper, findEntry | 1);\n    return true;\n  }\n  var frozenArray,\n    emptyArray = [];\n  setRawBitFlags(emptyArray, 55);\n  frozenArray = Object.freeze(emptyArray);\n  function throwIfFlag2(generatorWrapper) {\n    if (generatorWrapper & 2) {\n      throw Error();\n    }\n  }\n  var IteratorWithTransform = function (generatorWrapper, value, CustomMap) {\n    this.setTimeoutWrapper = 0;\n    this.entryIdCounter = generatorWrapper;\n    this.tasks = value;\n    this.createDeferred = CustomMap;\n  };\n  IteratorWithTransform.prototype.next = function () {\n    if (this.setTimeoutWrapper < this.entryIdCounter.length) {\n      var generatorWrapper = this.entryIdCounter[this.setTimeoutWrapper++];\n      return {\n        done: false,\n        value: this.tasks ? this.tasks.call(this.createDeferred, generatorWrapper) : generatorWrapper\n      };\n    }\n    return {\n      done: true,\n      value: undefined\n    };\n  };\n  IteratorWithTransform.prototype[Symbol.iterator] = function () {\n    return new IteratorWithTransform(this.entryIdCounter, this.tasks, this.createDeferred);\n  };\n  Object.freeze(new function () {}());\n  Object.freeze(new function () {}());\n  var setErrorContext = function (generatorWrapper, value) {\n    if (!generatorWrapper.__closure__error__context__984382) {\n      generatorWrapper.__closure__error__context__984382 = {};\n    }\n    generatorWrapper.__closure__error__context__984382.severity = value;\n  };\n  var undefinedVariable2;\n  function throwIncidentError() {\n    var generatorWrapper = Error();\n    setErrorContext(generatorWrapper, \"incident\");\n    deferError(generatorWrapper);\n  }\n  function createWarningError(generatorWrapper) {\n    generatorWrapper = Error(generatorWrapper);\n    setErrorContext(generatorWrapper, \"warning\");\n    return generatorWrapper;\n  }\n  function parseNumericValue(generatorWrapper) {\n    if (generatorWrapper == null || typeof generatorWrapper === \"number\") {\n      return generatorWrapper;\n    }\n    if (generatorWrapper === \"NaN\" || generatorWrapper === \"Infinity\" || generatorWrapper === \"-Infinity\") {\n      return Number(generatorWrapper);\n    }\n  }\n  function assertBoolean(generatorWrapper) {\n    if (typeof generatorWrapper !== \"boolean\") {\n      throw Error(\"Expected boolean but got \" + getType(generatorWrapper) + \": \" + generatorWrapper);\n    }\n    return generatorWrapper;\n  }\n  function parseNullableBoolean(generatorWrapper) {\n    if (generatorWrapper == null) {\n      return generatorWrapper;\n    } else {\n      return assertBoolean(generatorWrapper);\n    }\n  }\n  function parseBooleanOrNumber(generatorWrapper) {\n    if (generatorWrapper == null || typeof generatorWrapper === \"boolean\") {\n      return generatorWrapper;\n    }\n    if (typeof generatorWrapper === \"number\") {\n      return !!generatorWrapper;\n    }\n  }\n  var numericStringRegex = /^-?([1-9][0-9]*|0)(\\.[0-9]+)?$/;\n  function isNumericString(generatorWrapper) {\n    var value = typeof generatorWrapper;\n    if (value === \"number\") {\n      return Number.isFinite(generatorWrapper);\n    } else {\n      if (value !== \"string\") {\n        return false;\n      } else {\n        return numericStringRegex.test(generatorWrapper);\n      }\n    }\n  }\n  function parseIntEnum(generatorWrapper) {\n    if (!Number.isFinite(generatorWrapper)) {\n      throw createWarningError(\"enum\");\n    }\n    return generatorWrapper | 0;\n  }\n  function parseNullableIntEnum(generatorWrapper) {\n    if (generatorWrapper == null) {\n      return generatorWrapper;\n    } else {\n      return parseIntEnum(generatorWrapper);\n    }\n  }\n  function parseNullableInt(generatorWrapper) {\n    if (generatorWrapper == null) {\n      return generatorWrapper;\n    } else {\n      if (Number.isFinite(generatorWrapper)) {\n        return generatorWrapper | 0;\n      } else {\n        return undefined;\n      }\n    }\n  }\n  function parseInt32(generatorWrapper) {\n    if (typeof generatorWrapper !== \"number\") {\n      throw createWarningError(\"int32\");\n    }\n    if (!Number.isFinite(generatorWrapper)) {\n      throw createWarningError(\"int32\");\n    }\n    return generatorWrapper | 0;\n  }\n  function parseNullableInt32(generatorWrapper) {\n    if (generatorWrapper == null) {\n      return generatorWrapper;\n    }\n    if (typeof generatorWrapper === \"string\") {\n      if (!generatorWrapper) {\n        return;\n      }\n      generatorWrapper = +generatorWrapper;\n    }\n    if (typeof generatorWrapper === \"number\") {\n      if (Number.isFinite(generatorWrapper)) {\n        return generatorWrapper | 0;\n      } else {\n        return undefined;\n      }\n    }\n  }\n  function parseNullableUInt32(generatorWrapper) {\n    if (generatorWrapper == null) {\n      return generatorWrapper;\n    }\n    if (typeof generatorWrapper === \"string\") {\n      if (!generatorWrapper) {\n        return;\n      }\n      generatorWrapper = +generatorWrapper;\n    }\n    if (typeof generatorWrapper === \"number\") {\n      if (Number.isFinite(generatorWrapper)) {\n        return generatorWrapper >>> 0;\n      } else {\n        return undefined;\n      }\n    }\n  }\n  function convertToInt64(generatorWrapper) {\n    if (generatorWrapper != null) {\n      var value = !!value;\n      if (!isNumericString(generatorWrapper)) {\n        throw createWarningError(\"int64\");\n      }\n      if (typeof generatorWrapper === \"string\") {\n        generatorWrapper = convertStringToInt64(generatorWrapper);\n      } else if (value) {\n        generatorWrapper = convertNumberToString(generatorWrapper);\n      } else {\n        generatorWrapper = convertSafeInteger(generatorWrapper);\n      }\n    }\n    return generatorWrapper;\n  }\n  function isPositiveInt64(generatorWrapper) {\n    if (generatorWrapper[0] === \"-\") {\n      return false;\n    } else {\n      if (generatorWrapper.length < 20) {\n        return true;\n      } else {\n        return generatorWrapper.length === 20 && Number(generatorWrapper.substring(0, 6)) < 184467;\n      }\n    }\n  }\n  function isValidInt64Range(generatorWrapper) {\n    if (generatorWrapper[0] === \"-\") {\n      if (generatorWrapper.length < 20) {\n        return true;\n      } else {\n        return generatorWrapper.length === 20 && -922337 < Number(generatorWrapper.substring(0, 7));\n      }\n    } else {\n      if (generatorWrapper.length < 19) {\n        return true;\n      } else {\n        return generatorWrapper.length === 19 && Number(generatorWrapper.substring(0, 6)) < 922337;\n      }\n    }\n  }\n  function normalizeNumber(generatorWrapper) {\n    if (generatorWrapper < 0) {\n      calculateIntegers(generatorWrapper);\n      var value = formatLongNumber(lowOrderInteger, highOrderInteger);\n      generatorWrapper = Number(value);\n      if (Number.isSafeInteger(generatorWrapper)) {\n        return generatorWrapper;\n      } else {\n        return value;\n      }\n    }\n    if (isPositiveInt64(String(generatorWrapper))) {\n      return generatorWrapper;\n    }\n    calculateIntegers(generatorWrapper);\n    return 4294967296 * highOrderInteger + (lowOrderInteger >>> 0);\n  }\n  function convertSafeInteger(generatorWrapper) {\n    generatorWrapper = Math.trunc(generatorWrapper);\n    if (!Number.isSafeInteger(generatorWrapper)) {\n      calculateIntegers(generatorWrapper);\n      var value = lowOrderInteger;\n      var CustomMap = highOrderInteger;\n      if (generatorWrapper = CustomMap & 2147483648) {\n        value = ~value + 1 >>> 0;\n        CustomMap = ~CustomMap >>> 0;\n        if (value == 0) {\n          CustomMap = CustomMap + 1 >>> 0;\n        }\n      }\n      value = 4294967296 * CustomMap + (value >>> 0);\n      if (generatorWrapper) {\n        generatorWrapper = -value;\n      } else {\n        generatorWrapper = value;\n      }\n    }\n    return generatorWrapper;\n  }\n  function convertNumberToString(generatorWrapper) {\n    generatorWrapper = Math.trunc(generatorWrapper);\n    if (Number.isSafeInteger(generatorWrapper)) {\n      generatorWrapper = String(generatorWrapper);\n    } else {\n      var value = String(generatorWrapper);\n      if (isValidInt64Range(value)) {\n        generatorWrapper = value;\n      } else {\n        calculateIntegers(generatorWrapper);\n        generatorWrapper = getFormattedNumber();\n      }\n    }\n    return generatorWrapper;\n  }\n  function convertStringToInt64(generatorWrapper) {\n    var value = Math.trunc(Number(generatorWrapper));\n    if (Number.isSafeInteger(value)) {\n      return String(value);\n    }\n    value = generatorWrapper.indexOf(\".\");\n    if (-1 !== value) {\n      generatorWrapper = generatorWrapper.substring(0, value);\n    }\n    if (!isValidInt64Range(generatorWrapper)) {\n      parseAndSetBigIntegers(generatorWrapper);\n      generatorWrapper = getFormattedNumber();\n    }\n    return generatorWrapper;\n  }\n  function ensureString(generatorWrapper) {\n    if (typeof generatorWrapper !== \"string\") {\n      throw Error();\n    }\n    return generatorWrapper;\n  }\n  function optionalString(generatorWrapper) {\n    if (generatorWrapper != null && typeof generatorWrapper !== \"string\") {\n      throw Error();\n    }\n    return generatorWrapper;\n  }\n  function stringOrNull(generatorWrapper) {\n    if (generatorWrapper == null || typeof generatorWrapper === \"string\") {\n      return generatorWrapper;\n    } else {\n      return undefined;\n    }\n  }\n  function createObjectOrUndefined(generatorWrapper, value, CustomMap, findEntry) {\n    if (generatorWrapper != null && typeof generatorWrapper === \"object\" && generatorWrapper.emptyObject2 === emptyObject1) {\n      return generatorWrapper;\n    }\n    if (!Array.isArray(generatorWrapper)) {\n      if (CustomMap) {\n        if (findEntry & 2) {\n          return getSingletonInstance(value);\n        } else {\n          return new value();\n        }\n      } else {\n        return undefined;\n      }\n    }\n    var iterateEntries = CustomMap = getBitFlags(generatorWrapper);\n    if (iterateEntries === 0) {\n      iterateEntries |= findEntry & 32;\n    }\n    iterateEntries |= findEntry & 2;\n    if (iterateEntries !== CustomMap) {\n      setRawBitFlags(generatorWrapper, iterateEntries);\n    }\n    return new value(generatorWrapper);\n  }\n  function getSingletonInstance(generatorWrapper) {\n    var value = generatorWrapper[customProperty1];\n    if (value) {\n      return value;\n    }\n    value = new generatorWrapper();\n    setFlag34(value.getSingletonInstance);\n    return generatorWrapper[customProperty1] = value;\n  }\n  function getValidatedDataOrUndefined(generatorWrapper, value, CustomMap) {\n    if (value) {\n      return assertBoolean(generatorWrapper);\n    }\n    var findEntry;\n    if ((findEntry = parseBooleanOrNumber(generatorWrapper)) != null) {\n      return findEntry;\n    } else {\n      if (CustomMap) {\n        return false;\n      } else {\n        return undefined;\n      }\n    }\n  }\n  function getStringOrEmpty(generatorWrapper, value, CustomMap) {\n    if (value) {\n      return ensureString(generatorWrapper);\n    }\n    var findEntry;\n    if ((findEntry = stringOrNull(generatorWrapper)) != null) {\n      return findEntry;\n    } else {\n      if (CustomMap) {\n        return \"\";\n      } else {\n        return undefined;\n      }\n    }\n  }\n  var temporaryData;\n  function createInstanceWithTemporaryData(generatorWrapper, value) {\n    temporaryData = value;\n    generatorWrapper = new generatorWrapper(value);\n    temporaryData = undefined;\n    return generatorWrapper;\n  }\n  var booleanArrayCache, zeroValueArrayCache;\n  function convertToTuple(generatorWrapper) {\n    switch (typeof generatorWrapper) {\n      case \"boolean\":\n        return booleanArrayCache || (booleanArrayCache = [0, undefined, true]);\n      case \"number\":\n        if (generatorWrapper > 0) {\n          return undefined;\n        } else {\n          if (generatorWrapper === 0) {\n            return zeroValueArrayCache || (zeroValueArrayCache = [0, undefined]);\n          } else {\n            return [-generatorWrapper, undefined];\n          }\n        }\n      case \"string\":\n        return [0, generatorWrapper];\n      case \"object\":\n        return generatorWrapper;\n    }\n  }\n  function onFulfilled(generatorWrapper, value, CustomMap) {\n    if (generatorWrapper == null) {\n      generatorWrapper = temporaryData;\n    }\n    temporaryData = undefined;\n    if (generatorWrapper == null) {\n      var findEntry = 96;\n      if (CustomMap) {\n        generatorWrapper = [CustomMap];\n        findEntry |= 512;\n      } else {\n        generatorWrapper = [];\n      }\n      if (value) {\n        findEntry = findEntry & -16760833 | (value & 1023) << 14;\n      }\n    } else {\n      if (!Array.isArray(generatorWrapper)) {\n        throw Error(\"narr\");\n      }\n      findEntry = getBitFlags(generatorWrapper);\n      if (findEntry & 2048) {\n        throw Error(\"farr\");\n      }\n      if (findEntry & 64) {\n        return generatorWrapper;\n      }\n      findEntry |= 64;\n      if (CustomMap && (findEntry |= 512, CustomMap !== generatorWrapper[0])) {\n        throw Error(\"mid\");\n      }\n      generatorWrapper: {\n        CustomMap = generatorWrapper;\n        var iterateEntries = CustomMap.length;\n        if (iterateEntries) {\n          var createCircularNode = iterateEntries - 1;\n          if (isPlainObject(CustomMap[createCircularNode])) {\n            findEntry |= 256;\n            value = createCircularNode - (+!!(findEntry & 512) - 1);\n            if (value >= 1024) {\n              throw Error(\"pvtlmt\");\n            }\n            findEntry = findEntry & -16760833 | (value & 1023) << 14;\n            break generatorWrapper;\n          }\n        }\n        if (value) {\n          value = Math.max(value, iterateEntries - (+!!(findEntry & 512) - 1));\n          if (value > 1024) {\n            throw Error(\"spvt\");\n          }\n          findEntry = findEntry & -16760833 | (value & 1023) << 14;\n        }\n      }\n    }\n    setRawBitFlags(generatorWrapper, findEntry);\n    return generatorWrapper;\n  }\n  var polyfillCheckCache = {};\n  var requiresPolyfill = function () {\n    try {\n      var generatorWrapper = function () {\n        return constructReflect(Map, [], this.constructor);\n      };\n      inheritPrototype(generatorWrapper, Map);\n      noopFunction(new generatorWrapper());\n      return false;\n    } catch (value) {\n      return true;\n    }\n  }();\n  var CustomMap = function () {\n    this.entryIdCounter = new Map();\n  };\n  setTimeoutWrapper = CustomMap.prototype;\n  setTimeoutWrapper.get = function (generatorWrapper) {\n    return this.entryIdCounter.get(generatorWrapper);\n  };\n  setTimeoutWrapper.set = function (generatorWrapper, value) {\n    this.entryIdCounter.set(generatorWrapper, value);\n    this.size = this.entryIdCounter.size;\n    return this;\n  };\n  setTimeoutWrapper.delete = function (generatorWrapper) {\n    generatorWrapper = this.entryIdCounter.delete(generatorWrapper);\n    this.size = this.entryIdCounter.size;\n    return generatorWrapper;\n  };\n  setTimeoutWrapper.clearAll = function () {\n    this.entryIdCounter.clearAll();\n    this.size = this.entryIdCounter.size;\n  };\n  setTimeoutWrapper.has = function (generatorWrapper) {\n    return this.entryIdCounter.has(generatorWrapper);\n  };\n  setTimeoutWrapper.entries = function () {\n    return this.entryIdCounter.entries();\n  };\n  setTimeoutWrapper.keys = function () {\n    return this.entryIdCounter.keys();\n  };\n  setTimeoutWrapper.values = function () {\n    return this.entryIdCounter.values();\n  };\n  setTimeoutWrapper.forEach = function (generatorWrapper, value) {\n    return this.entryIdCounter.forEach(generatorWrapper, value);\n  };\n  CustomMap.prototype[Symbol.iterator] = function () {\n    return this.entries();\n  };\n  var PolyfilledMap = function () {\n    if (requiresPolyfill) {\n      Object.setPrototypeOf(CustomMap.prototype, Map.prototype);\n      Object.defineProperties(CustomMap.prototype, {\n        size: {\n          value: 0,\n          configurable: true,\n          enumerable: true,\n          writable: true\n        }\n      });\n      return CustomMap;\n    }\n    var generatorWrapper = function () {\n      return constructReflect(Map, [], this.constructor);\n    };\n    inheritPrototype(generatorWrapper, Map);\n    return generatorWrapper;\n  }();\n  function identityFunction(generatorWrapper) {\n    return generatorWrapper;\n  }\n  var EnhancedMap = function (generatorWrapper, value, CustomMap, findEntry) {\n    if (undefined === CustomMap) {\n      CustomMap = identityFunction;\n    } else {\n      CustomMap = CustomMap;\n    }\n    if (undefined === findEntry) {\n      findEntry = identityFunction;\n    } else {\n      findEntry = findEntry;\n    }\n    var iterateEntries = PolyfilledMap.call(this) || this;\n    var createCircularNode = getBitFlags(generatorWrapper);\n    createCircularNode |= 64;\n    setRawBitFlags(generatorWrapper, createCircularNode);\n    iterateEntries.mapElements = createCircularNode;\n    iterateEntries.ProtobufWriter = value;\n    iterateEntries.keyTransformFunction = CustomMap;\n    if (iterateEntries.ProtobufWriter) {\n      iterateEntries.convertToInt64 = TransformValue;\n    } else {\n      iterateEntries.convertToInt64 = findEntry;\n    }\n    for (var entryIdCounter = 0; entryIdCounter < generatorWrapper.length; entryIdCounter++) {\n      var key = generatorWrapper[entryIdCounter];\n      var value = CustomMap(key[0], false, true);\n      var entry = key[1];\n      if (value) {\n        if (undefined === entry) {\n          entry = null;\n        }\n      } else {\n        entry = findEntry(key[1], false, true, undefined, undefined, createCircularNode);\n      }\n      PolyfilledMap.prototype.set.call(iterateEntries, value, entry);\n    }\n    return iterateEntries;\n  };\n  inheritPrototype(EnhancedMap, PolyfilledMap);\n  var EnsureMutable = function (generatorWrapper) {\n    if (generatorWrapper.mapElements & 2) {\n      throw Error(\"Cannot mutate an immutable Map\");\n    }\n  };\n  var TransformMapEntries = function (generatorWrapper, value) {\n    if (undefined === value) {\n      value = IdentityTransform;\n    } else {\n      value = value;\n    }\n    if (generatorWrapper.size !== 0) {\n      return TransformEntries(generatorWrapper, value);\n    }\n  };\n  var TransformEntries = function (generatorWrapper, value) {\n    if (undefined === value) {\n      value = IdentityTransform;\n    } else {\n      value = value;\n    }\n    var CustomMap = [];\n    generatorWrapper = PolyfilledMap.prototype.entr"