"= 400) {\n        settlePromise(resolvePromise.getAdInstance(), \"lvlfes\", findEntry.status.toString());\n        generatorWrapper.handleAsync = findEntry.status;\n        return value.return(Promise.reject());\n      }\n      if ((iterateEntries = findEntry.body) == null) {\n        createCircularNode = undefined;\n      } else {\n        createCircularNode = iterateEntries.getReader();\n      }\n      if (!createCircularNode) {\n        logError(\"lvlmr\");\n        generatorWrapper.handleAsync = findEntry.status;\n        return value.return(Promise.reject());\n      }\n      entryIdCounter = [];\n      key = function () {\n        var entry, currentEntry, foundEntry, resolveFunction, rejectFunction, user;\n        return wrapGeneratorToPromise(function (profileData) {\n          if (profileData.entryIdCounter == 1) {\n            return generatorYield(profileData, createCircularNode.read(), 2);\n          }\n          entry = profileData.tasks;\n          currentEntry = entry.done;\n          foundEntry = entry.value;\n          if (currentEntry) {\n            resolveFunction = value < CustomMap;\n            finalizeMediaBuffer(generatorWrapper, entryIdCounter, resolveFunction);\n            return profileData.return();\n          }\n          entryIdCounter.push(foundEntry);\n          if ((rejectFunction = foundEntry) == null) {\n            value += undefined;\n          } else {\n            value += rejectFunction.length;\n          }\n          dispatchMediaProgressEvent(generatorWrapper, (user = foundEntry) == null ? undefined : user.buffer);\n          return generatorYield(profileData, key(), 0);\n        });\n      };\n      return generatorYield(value, key(), 0);\n    });\n  };\n  var finalizeMediaBuffer = function (generatorWrapper, value, CustomMap) {\n    if (CustomMap) {\n      generatorWrapper.state = 3;\n      dispatchMediaProgressEvent(generatorWrapper, new ArrayBuffer(0));\n    }\n    var findEntry = new Uint8Array(value.reduce(function (entryIdCounter, key) {\n      return entryIdCounter + key.length;\n    }, 0));\n    var iterateEntries = 0;\n    value = getIterator(value);\n    for (var createCircularNode = value.next(); !createCircularNode.done; createCircularNode = value.next()) {\n      createCircularNode = createCircularNode.value;\n      findEntry.set(createCircularNode, iterateEntries);\n      iterateEntries += createCircularNode.length;\n    }\n    if (generatorWrapper.tasks && findEntry.buffer.byteLength > 0) {\n      generatorWrapper.tasks.isIpod(findEntry.buffer, generatorWrapper.uri, 0, CustomMap);\n    }\n  };\n  var dispatchMediaProgressEvent = function (generatorWrapper, value) {\n    if (value !== null) {\n      value = value.slice(0);\n      generatorWrapper.setTimeoutWrapper += value.byteLength;\n      generatorWrapper.dispatchEvent({\n        type: \"progress\",\n        CustomError: value\n      });\n    }\n  };\n  MediaSourceLoader.prototype.getAdEnvironment = function () {\n    var generatorWrapper;\n    if ((generatorWrapper = this.tasks) == null ? 0 : generatorWrapper.getUniqueId()) {\n      this.tasks.closeCache();\n    }\n    MediaElement.prototype.getAdEnvironment.call(this);\n  };\n  var UriParameterManager = function (generatorWrapper) {\n    this.uri = generatorWrapper;\n    this.entryIdCounter = parseUriParameters(generatorWrapper);\n  };\n  var parseUriParameters = function (generatorWrapper) {\n    return new Map(generatorWrapper.setTimeoutWrapper.split(\"/\").reduce(function (value, CustomMap, findEntry, iterateEntries) {\n      if (findEntry % 2) {\n        value.set(iterateEntries[findEntry - 1], CustomMap);\n      }\n      return value;\n    }, new Map()));\n  };\n  UriParameterManager.prototype.getAdId = function () {\n    return getParameterById(this, \"id\");\n  };\n  var getRangeStart = function (generatorWrapper) {\n    generatorWrapper = generatorWrapper.uri.entryIdCounter.get(\"range\");\n    if (!generatorWrapper) {\n      return null;\n    }\n    generatorWrapper = generatorWrapper.split(\"-\")[0];\n    if (!generatorWrapper || isNaN(Number(generatorWrapper))) {\n      return null;\n    } else {\n      return Number(generatorWrapper);\n    }\n  };\n  var getParameterById = function (generatorWrapper, value) {\n    var CustomMap = generatorWrapper.uri.entryIdCounter.get(value);\n    if (CustomMap) {\n      return CustomMap;\n    } else {\n      if (generatorWrapper = generatorWrapper.entryIdCounter.get(value)) {\n        return generatorWrapper;\n      } else {\n        return null;\n      }\n    }\n  };\n  var EmptyFunction = function () {};\n  var trustedDomains = [\"doubleclick.net\"];\n  function isSupportedEnvironment() {\n    if (isIphone() || handleAsync(\"iPad\") || handleAsync(\"iPod\")) {\n      return false;\n    }\n    if (isAndroid()) {\n      if (undefined === trustedDomainsListCache) {\n        generatorWrapper: {\n          if (undefined === userAgentStringCache) {\n            if (isAppleDevice) {\n              var generatorWrapper = includesString(getUserAgentString(), \"Safari\");\n              var value = new table(window.location.href).entryIdCounter.hasPlatform(\"js\");\n              value: {\n                if ((value = value.length ? value[0] : \"\") && value.lastIndexOf(\"afma-\", 0) == 0) {\n                  var CustomMap = value.lastIndexOf(\"v\");\n                  if (-1 < CustomMap && (value = value.substr(CustomMap + 1).match(/^(\\d+\\.\\d+\\.\\d+|^\\d+\\.\\d+|^\\d+)(-.*)?$/))) {\n                    value = value[1];\n                    break value;\n                  }\n                }\n                value = \"0.0.0\";\n              }\n              if (!generatorWrapper || value !== \"0.0.0\") {\n                generatorWrapper = userAgentStringCache = true;\n                break generatorWrapper;\n              }\n            }\n            userAgentStringCache = false;\n          }\n          generatorWrapper = userAgentStringCache;\n        }\n        if (!generatorWrapper) {\n          if (undefined === isAppleDeviceCache) {\n            if (includesString(getUserAgentString(), \"afma-sdk-a\")) {\n              isAppleDeviceCache = true;\n            } else {\n              isAppleDeviceCache = false;\n            }\n          }\n          generatorWrapper = isAppleDeviceCache;\n        }\n        trustedDomainsListCache = generatorWrapper;\n      }\n      if (trustedDomainsListCache) {\n        return true;\n      } else {\n        if (isTablet()) {\n          return false;\n        } else {\n          return isTrustedDomain();\n        }\n      }\n    }\n    generatorWrapper = isMacOS() || (hasPlatform() ? userAgentData.platform === \"Linux\" : handleAsync(\"Linux\")) || (hasPlatform() ? userAgentData.platform === \"Windows\" : handleAsync(\"Windows\")) || (hasPlatform() ? userAgentData.platform === \"Chrome OS\" : handleAsync(\"CrOS\"));\n    if ((handleThenable(vm) || handleThenable(tm) || handleThenable(um)) && generatorWrapper && isChromiumBased()) {\n      return isTrustedDomain();\n    } else {\n      return false;\n    }\n  }\n  function isTrustedDomain() {\n    var generatorWrapper = false;\n    var value = new table(window.location.href).tasks;\n    trustedDomains.forEach(function (CustomMap) {\n      if (value.includes(CustomMap)) {\n        generatorWrapper = true;\n      }\n    });\n    return generatorWrapper;\n  }\n  var ErrorBase,\n    CustomError = function (generatorWrapper, value, CustomMap) {\n      if (typeof generatorWrapper === \"number\") {\n        var findEntry = {\n          name: getNameFromError(generatorWrapper)\n        };\n      } else {\n        findEntry = generatorWrapper;\n        generatorWrapper = getErrorFromName(generatorWrapper.name);\n      }\n      this.code = generatorWrapper;\n      this.entryIdCounter = findEntry;\n      value = \"Error \" + value + \": \" + this.getAdName();\n      if (CustomMap) {\n        value += \", \" + CustomMap;\n      }\n      CustomError.call(this, value);\n    };\n  inheritPrototype(CustomError, CustomError);\n  CustomError.prototype.getAdName = function () {\n    return this.entryIdCounter.name || \"\";\n  };\n  var ErrorCodes = {\n    getAdPropertyNumericValue: 1,\n    isMobile: 2,\n    NOT_FOUND_ERR: 3,\n    rf: 4,\n    uf: 5,\n    extractBaseUrl: 6,\n    getNumericAdProperty: 7,\n    ABORT_ERR: 8,\n    getAdPropertyValue: 9,\n    createHtmlElement: 10,\n    TIMEOUT_ERR: 11,\n    getAdProperty: 12,\n    INVALID_ACCESS_ERR: 13,\n    INVALID_STATE_ERR: 14\n  };\n  var UnknownErrorCode = (globalScope.entryIdCounter || globalScope.tasks || ErrorCodes).getAdPropertyNumericValue;\n  var NotFoundErrorCode = (globalScope.entryIdCounter || globalScope.tasks || ErrorCodes).NOT_FOUND_ERR;\n  var ConstraintErrorCode = (globalScope.entryIdCounter || globalScope.tasks || ErrorCodes).rf;\n  var DataErrorCode = (globalScope.entryIdCounter || globalScope.tasks || ErrorCodes).uf;\n  var TransactionInactiveErrorCode = (globalScope.entryIdCounter || globalScope.tasks || ErrorCodes).getNumericAdProperty;\n  var AbortErrorCode = (globalScope.entryIdCounter || globalScope.tasks || ErrorCodes).ABORT_ERR;\n  var ReadOnlyErrorCode = (globalScope.entryIdCounter || globalScope.tasks || ErrorCodes).getAdPropertyValue;\n  var TimeoutErrorCode = (globalScope.entryIdCounter || globalScope.tasks || ErrorCodes).TIMEOUT_ERR;\n  var QuotaExceededErrorCode = (globalScope.entryIdCounter || globalScope.tasks || ErrorCodes).getAdProperty;\n  var InvalidAccessErrorCode = (globalScope.DOMException || ErrorCodes).INVALID_ACCESS_ERR;\n  var InvalidStateErrorCode = (globalScope.DOMException || ErrorCodes).INVALID_STATE_ERR;\n  var getErrorFromName = function (generatorWrapper) {\n    switch (generatorWrapper) {\n      case \"UnknownError\":\n        return UnknownErrorCode;\n      case \"NotFoundError\":\n        return NotFoundErrorCode;\n      case \"ConstraintError\":\n        return ConstraintErrorCode;\n      case \"DataError\":\n        return DataErrorCode;\n      case \"TransactionInactiveError\":\n        return TransactionInactiveErrorCode;\n      case \"AbortError\":\n        return AbortErrorCode;\n      case \"ReadOnlyError\":\n        return ReadOnlyErrorCode;\n      case \"TimeoutError\":\n        return TimeoutErrorCode;\n      case \"QuotaExceededError\":\n        return QuotaExceededErrorCode;\n      case \"InvalidAccessError\":\n        return InvalidAccessErrorCode;\n      case \"InvalidStateError\":\n        return InvalidStateErrorCode;\n      default:\n        return UnknownErrorCode;\n    }\n  };\n  var getNameFromError = function (generatorWrapper) {\n    switch (generatorWrapper) {\n      case UnknownErrorCode:\n        return \"UnknownError\";\n      case NotFoundErrorCode:\n        return \"NotFoundError\";\n      case ConstraintErrorCode:\n        return \"ConstraintError\";\n      case DataErrorCode:\n        return \"DataError\";\n      case TransactionInactiveErrorCode:\n        return \"TransactionInactiveError\";\n      case AbortErrorCode:\n        return \"AbortError\";\n      case ReadOnlyErrorCode:\n        return \"ReadOnlyError\";\n      case TimeoutErrorCode:\n        return \"TimeoutError\";\n      case QuotaExceededErrorCode:\n        return \"QuotaExceededError\";\n      case InvalidAccessErrorCode:\n        return \"InvalidAccessError\";\n      case InvalidStateErrorCode:\n        return \"InvalidStateError\";\n      default:\n        return \"UnknownError\";\n    }\n  };\n  var createErrorFromRequest = function (generatorWrapper, value) {\n    if (\"error\" in generatorWrapper) {\n      return new CustomError(generatorWrapper.hasError, value);\n    } else {\n      return new CustomError({\n        name: \"UnknownError\"\n      }, value);\n    }\n  };\n  var createErrorFromException = function (generatorWrapper, value) {\n    if (\"name\" in generatorWrapper) {\n      return new CustomError(generatorWrapper, value + \": \" + generatorWrapper.message);\n    } else {\n      return new CustomError({\n        name: \"UnknownError\"\n      }, value);\n    }\n  };\n  var KeyRangeWrapper = function (generatorWrapper) {\n    this.entryIdCounter = generatorWrapper;\n  };\n  var IndexedDBKeyRange = globalScope.IDBKeyRange || globalScope.webkitIDBKeyRange;\n  function PromiseBase() {}\n  var Deferred = function (generatorWrapper, value) {\n    this.handleAsync = [];\n    this.resolvePromise = generatorWrapper;\n    this.handleThenable = value || null;\n    this.createDeferred = this.setTimeoutWrapper = false;\n    this.tasks = undefined;\n    this.executeCallbacks = this.logError = this.onFulfilled = false;\n    this.isDone = 0;\n    this.entryIdCounter = null;\n    this.settlePromise = 0;\n  };\n  inheritPrototype(Deferred, PromiseBase);\n  Deferred.prototype.cancel = function (generatorWrapper) {\n    if (this.setTimeoutWrapper) {\n      if (this.tasks instanceof Deferred) {\n        this.tasks.cancel();\n      }\n    } else {\n      if (this.entryIdCounter) {\n        var value = this.entryIdCounter;\n        delete this.entryIdCounter;\n        if (generatorWrapper) {\n          value.cancel(generatorWrapper);\n        } else {\n          value.settlePromise--;\n          if (value.settlePromise <= 0) {\n            value.cancel();\n          }\n        }\n      }\n      if (this.resolvePromise) {\n        this.resolvePromise.call(this.handleThenable, this);\n      } else {\n        this.executeCallbacks = true;\n      }\n      if (!this.setTimeoutWrapper) {\n        rejectPromise(this, new CanceledError(this));\n      }\n    }\n  };\n  Deferred.prototype.dispatchUnhandledRejection = function (generatorWrapper, value) {\n    this.onFulfilled = false;\n    executeCallbacks(this, generatorWrapper, value);\n  };\n  var executeCallbacks = function (generatorWrapper, value, CustomMap) {\n    generatorWrapper.setTimeoutWrapper = true;\n    generatorWrapper.tasks = CustomMap;\n    generatorWrapper.createDeferred = !value;\n    processCallbackQueue(generatorWrapper);\n  };\n  var assertNotFired = function (generatorWrapper) {\n    if (generatorWrapper.setTimeoutWrapper) {\n      if (!generatorWrapper.executeCallbacks) {\n        throw new AlreadyCalledError(generatorWrapper);\n      }\n      generatorWrapper.executeCallbacks = false;\n    }\n  };\n  Deferred.prototype.resetGeneratorState = function (generatorWrapper) {\n    assertNotFired(this);\n    executeCallbacks(this, true, generatorWrapper);\n  };\n  var rejectPromise = function (generatorWrapper, value) {\n    assertNotFired(generatorWrapper);\n    executeCallbacks(generatorWrapper, false, value);\n  };\n  var addToCallbackQueueWithoutContext = function (generatorWrapper, value) {\n    return addToCallbackQueue(generatorWrapper, value, null);\n  };\n  var addToCallbackQueue = function (generatorWrapper, value, CustomMap, findEntry) {\n    generatorWrapper.handleAsync.push([value, CustomMap, findEntry]);\n    if (generatorWrapper.setTimeoutWrapper) {\n      processCallbackQueue(generatorWrapper);\n    }\n    return generatorWrapper;\n  };\n  Deferred.prototype.then = function (generatorWrapper, value, CustomMap) {\n    var findEntry,\n      iterateEntries,\n      createCircularNode = new PromisePolyfill(function (entryIdCounter, key) {\n        iterateEntries = entryIdCounter;\n        findEntry = key;\n      });\n    addToCallbackQueue(this, iterateEntries, function (entryIdCounter) {\n      if (entryIdCounter instanceof CanceledError) {\n        createCircularNode.cancel();\n      } else {\n        findEntry(entryIdCounter);\n      }\n      return callbackMarker;\n    }, this);\n    return createCircularNode.then(generatorWrapper, value, CustomMap);\n  };\n  Deferred.prototype.$goog_Thenable = true;\n  var hasCallbacks = function (generatorWrapper) {\n    return someElement(generatorWrapper.handleAsync, function (value) {\n      return typeof value[1] === \"function\";\n    });\n  };\n  var callbackMarker = {};\n  var processCallbackQueue = function (generatorWrapper) {\n    if (generatorWrapper.isDone && generatorWrapper.setTimeoutWrapper && hasCallbacks(generatorWrapper)) {\n      var value = generatorWrapper.isDone;\n      var CustomMap = timeoutRegistry[value];\n      if (CustomMap) {\n        globalScope.clearTimeout(CustomMap.entryIdCounter);\n        delete timeoutRegistry[value];\n      }\n      generatorWrapper.isDone = 0;\n    }\n    if (generatorWrapper.entryIdCounter) {\n      generatorWrapper.entryIdCounter.settlePromise--;\n      delete generatorWrapper.entryIdCounter;\n    }\n    value = generatorWrapper.tasks;\n    for (var findEntry = CustomMap = false; generatorWrapper.handleAsync.length && !generatorWrapper.onFulfilled;) {\n      var iterateEntries = generatorWrapper.handleAsync.shift();\n      var createCircularNode = iterateEntries[0];\n      var entryIdCounter = iterateEntries[1];\n      iterateEntries = iterateEntries[2];\n      if (createCircularNode = generatorWrapper.createDeferred ? entryIdCounter : createCircularNode) {\n        try {\n          var key = createCircularNode.call(iterateEntries || generatorWrapper.handleThenable, value);\n          if (key === callbackMarker) {\n            key = undefined;\n          }\n          if (undefined !== key) {\n            generatorWrapper.createDeferred = generatorWrapper.createDeferred && (key == value || key instanceof Error);\n            generatorWrapper.tasks = value = key;\n          }\n          if (isThenable(value) || typeof globalScope.Promise === \"function\" && value instanceof globalScope.Promise) {\n            findEntry = true;\n            generatorWrapper.onFulfilled = true;\n          }\n        } catch (value) {\n          value = value;\n          generatorWrapper.createDeferred = true;\n          if (!hasCallbacks(generatorWrapper)) {\n            CustomMap = true;\n          }\n        }\n      }\n    }\n    generatorWrapper.tasks = value;\n    if (findEntry) {\n      key = bindOrWrapFunction(generatorWrapper.dispatchUnhandledRejection, generatorWrapper, true);\n      findEntry = bindOrWrapFunction(generatorWrapper.dispatchUnhandledRejection, generatorWrapper, false);\n      if (value instanceof Deferred) {\n        addToCallbackQueue(value, key, findEntry);\n        value.logError = true;\n      } else {\n        value.then(key, findEntry);\n      }\n    }\n    if (CustomMap) {\n      value = new TimeoutError(value);\n      timeoutRegistry[value.entryIdCounter] = value;\n      generatorWrapper.isDone = value.entryIdCounter;\n    }\n  };\n  var AlreadyCalledError = function () {\n    CustomError.call(this);\n  };\n  inheritPrototype(AlreadyCalledError, CustomError);\n  AlreadyCalledError.prototype.message = \"Deferred has already fired\";\n  AlreadyCalledError.prototype.name = \"AlreadyCalledError\";\n  var CanceledError = function () {\n    CustomError.call(this);\n  };\n  inheritPrototype(CanceledError, CustomError);\n  CanceledError.prototype.message = \"Deferred was canceled\";\n  CanceledError.prototype.name = \"CanceledError\";\n  var TimeoutError = function (generatorWrapper) {\n    this.entryIdCounter = globalScope.setTimeout(bindOrWrapFunction(this.setTimeoutWrapper, this), 0);\n    this.tasks = generatorWrapper;\n  };\n  TimeoutError.prototype.setTimeoutWrapper = function () {\n    delete timeoutRegistry[this.entryIdCounter];\n    throw this.tasks;\n  };\n  var timeoutRegistry = {};\n  var CursorRequest = function () {\n    AdEnvironmentConfig.call(this);\n  };\n  inheritPrototype(CursorRequest, AdEnvironmentConfig);\n  CursorRequest.prototype.entryIdCounter = null;\n  CursorRequest.prototype.next = function (generatorWrapper) {\n    if (generatorWrapper) {\n      this.entryIdCounter[\"continue\"](generatorWrapper);\n    } else {\n      this.entryIdCounter[\"continue\"]();\n    }\n  };\n  CursorRequest.prototype.removeElement = function () {\n    var generatorWrapper = new Deferred();\n    try {\n      var value = this.entryIdCounter[\"delete\"]();\n    } catch (CustomMap) {\n      rejectPromise(generatorWrapper, createErrorFromException(CustomMap, \"deleting via cursor\"));\n      return generatorWrapper;\n    }\n    value.onsuccess = function () {\n      generatorWrapper.resetGeneratorState();\n    };\n    value.onerror = function (CustomMap) {\n      rejectPromise(generatorWrapper, createErrorFromRequest(CustomMap.target, \"deleting via cursor\"));\n    };\n    return generatorWrapper;\n  };\n  CursorRequest.prototype.getAdStateValue = function () {\n    return this.entryIdCounter.value;\n  };\n  var openCursor = function (generatorWrapper, value) {\n    var CustomMap = new CursorRequest();\n    try {\n      var findEntry = generatorWrapper.openCursor(value ? value.entryIdCounter : null);\n    } catch (iterateEntries) {\n      CustomMap.markAsCompleted();\n      throw createErrorFromException(iterateEntries, generatorWrapper.name);\n    }\n    findEntry.onsuccess = function (iterateEntries) {\n      CustomMap.entryIdCounter = iterateEntries.target.result || null;\n      if (CustomMap.entryIdCounter) {\n        CustomMap.dispatchEvent(\"n\");\n      } else {\n        CustomMap.dispatchEvent(\"c\");\n      }\n    };\n    findEntry.onerror = function () {\n      CustomMap.dispatchEvent(\"e\");\n    };\n    return CustomMap;\n  };\n  var IndexRequest = function (generatorWrapper) {\n    this.entryIdCounter = generatorWrapper;\n  };\n  IndexRequest.prototype.getAdName = function () {\n    return this.entryIdCounter.name;\n  };\n  var getIndex = function (generatorWrapper, value, CustomMap) {\n    var findEntry = new Deferred();\n    try {\n      var iterateEntries = generatorWrapper.entryIdCounter.get(CustomMap);\n    } catch (createCircularNode) {\n      value += \" with key \" + debugStringifyObject(CustomMap);\n      rejectPromise(findEntry, createErrorFromException(createCircularNode, value));\n      return findEntry;\n    }\n    iterateEntries.onsuccess = function (createCircularNode) {\n      findEntry.resetGeneratorState(createCircularNode.target.result);\n    };\n    iterateEntries.onerror = function (createCircularNode) {\n      value += \" with key \" + debugStringifyObject(CustomMap);\n      rejectPromise(findEntry, createErrorFromRequest(createCircularNode.target, value));\n    };\n    return findEntry;\n  };\n  IndexRequest.prototype.get = function (generatorWrapper) {\n    return getIndex(this, \"getting from index \" + this.getAdName(), generatorWrapper);\n  };\n  var openIndexCursor = function (generatorWrapper, value) {\n    return openCursor(generatorWrapper.entryIdCounter, value);\n  };\n  var ObjectStoreRequest = function (generatorWrapper) {\n    this.entryIdCounter = generatorWrapper;\n  };\n  ObjectStoreRequest.prototype.getAdName = function () {\n    return this.entryIdCounter.name;\n  };\n  var executeStoreRequest = function (generatorWrapper, value, CustomMap, findEntry, iterateEntries) {\n    var createCircularNode = new Deferred();\n    try {\n      var entryIdCounter = iterateEntries ? generatorWrapper.entryIdCounter[value](findEntry, iterateEntries) : generatorWrapper.entryIdCounter[value](findEntry);\n    } catch (key) {\n      CustomMap += debugStringifyObject(findEntry);\n      if (iterateEntries) {\n        CustomMap += \", with key \" + debugStringifyObject(iterateEntries);\n      }\n      rejectPromise(createCircularNode, createErrorFromException(key, CustomMap));\n      return createCircularNode;\n    }\n    entryIdCounter.onsuccess = function (key) {\n      createCircularNode.resetGeneratorState(key.target.result);\n    };\n    entryIdCounter.onerror = function (key) {\n      CustomMap += debugStringifyObject(findEntry);\n      if (iterateEntries) {\n        CustomMap += \", with key \" + debugStringifyObject(iterateEntries);\n      }\n      rejectPromise(createCircularNode, createErrorFromRequest(key.target, CustomMap));\n    };\n    return createCircularNode;\n  };\n  var putValue = function (generatorWrapper, value) {\n    return executeStoreRequest(generatorWrapper, \"put\", \"putting into \" + generatorWrapper.getAdName() + \" with value\", value);\n  };\n  ObjectStoreRequest.prototype.addParameter = function (generatorWrapper, value) {\n    return executeStoreRequest(this, \"add\", \"adding into \" + this.getAdName() + \" with value \", generatorWrapper, value);\n  };\n  ObjectStoreRequest.prototype.removeElement = function (generatorWrapper) {\n    var value = new Deferred();\n    try {\n      var CustomMap = this.entryIdCounter[\"delete\"](generatorWrapper instanceof KeyRangeWrapper ? generatorWrapper.entryIdCounter : generatorWrapper);\n    } catch (iterateEntries) {\n      CustomMap = \"removing from \" + this.getAdName() + \" with key \" + debugStringifyObject(generatorWrapper);\n      rejectPromise(value, createErrorFromException(iterateEntries, CustomMap));\n      return value;\n    }\n    CustomMap.onsuccess = function () {\n      value.resetGeneratorState();\n    };\n    var findEntry = this;\n    CustomMap.onerror = function (iterateEntries) {\n      var createCircularNode = \"removing from \" + findEntry.getAdName() + \" with key \" + debugStringifyObject(generatorWrapper);\n      rejectPromise(value, createErrorFromRequest(iterateEntries.target, createCircularNode));\n    };\n    return value;\n  };\n  ObjectStoreRequest.prototype.get = function (generatorWrapper) {\n    var value = new Deferred();\n    try {\n      var CustomMap = this.entryIdCounter.get(generatorWrapper);\n    } catch (iterateEntries) {\n      CustomMap = \"getting from \" + this.getAdName() + \" with key \" + debugStringifyObject(generatorWrapper);\n      rejectPromise(value, createErrorFromException(iterateEntries, CustomMap));\n      return value;\n    }\n    CustomMap.onsuccess = function (iterateEntries) {\n      value.resetGeneratorState(iterateEntries.target.result);\n    };\n    var findEntry = this;\n    CustomMap.onerror = function (iterateEntries) {\n      var createCircularNode = \"getting from \" + findEntry.getAdName() + \" with key \" + debugStringifyObject(generatorWrapper);\n      rejectPromise(value, createErrorFromRequest(iterateEntries.target, createCircularNode));\n    };\n    return value;\n  };\n  ObjectStoreRequest.prototype.clearAll = function () {\n    var generatorWrapper = \"clearing store \" + this.getAdName();\n    var value = new Deferred();\n    try {\n      var CustomMap = this.entryIdCounter.clearAll();\n    } catch (findEntry) {\n      rejectPromise(value, createErrorFromException(findEntry, generatorWrapper));\n      return value;\n    }\n    CustomMap.onsuccess = function () {\n      value.resetGeneratorState();\n    };\n    CustomMap.onerror = function (findEntry) {\n      rejectPromise(value, createErrorFromRequest(findEntry.target, generatorWrapper));\n    };\n    return value;\n  };\n  var getIndexTimestamp = function (generatorWrapper) {\n    try {\n      return new IndexRequest(generatorWrapper.entryIdCounter.index(\"timestamp\"));\n    } catch (value) {\n      throw createErrorFromException(value, \"getting index timestamp\");\n    }\n  };\n  var TransactionRequest = function (generatorWrapper, value) {\n    AdEnvironmentConfig.call(this);\n    this.entryIdCounter = generatorWrapper;\n    this.setTimeoutWrapper = value;\n    this.tasks = new EventDispatcher(this);\n    this.tasks.window(this.entryIdCounter, \"complete\", bindOrWrapFunction(this.dispatchEvent, this, \"complete\"));\n    this.tasks.window(this.entryIdCounter, \"abort\", bindOrWrapFunction(this.dispatchEvent, this, \"abort\"));\n    this.tasks.window(this.entryIdCounter, \"error\", this.fetchData);\n  };\n  inheritPrototype(TransactionRequest, AdEnvironmentConfig);\n  setTimeoutWrapper = TransactionRequest.prototype;\n  setTimeoutWrapper.fetchData = function (generatorWrapper) {\n    if (generatorWrapper.target instanceof CustomError) {\n      this.dispatchEvent({\n        type: \"error\",\n        target: generatorWrapper.target\n      });\n    } else {\n      this.dispatchEvent({\n        type: \"error\",\n        target: createErrorFromRequest(generatorWrapper.target, \"in transaction\")\n      });\n    }\n  };\n  setTimeoutWrapper.objectStore = function (generatorWrapper) {\n    try {\n      return new ObjectStoreRequest(this.entryIdCounter.objectStore(generatorWrapper));\n    } catch (value) {\n      throw createErrorFromException(value, \"getting object store \" + generatorWrapper);\n    }\n  };\n  setTimeoutWrapper.commit = function (generatorWrapper) {\n    if (this.entryIdCounter.commit || !generatorWrapper) {\n      try {\n        this.entryIdCounter.commit();\n      } catch (value) {\n        throw createErrorFromException(value, \"cannot commit the transaction\");\n      }\n    }\n  };\n  setTimeoutWrapper.wait = function () {\n    var generatorWrapper = new Deferred();\n    Gu(this, \"complete\", bindOrWrapFunction(generatorWrapper.resetGeneratorState, generatorWrapper));\n    var value = Gu(this, \"abort\", function () {\n      Pu(CustomMap);\n      rejectPromise(generatorWrapper, new CustomError(AbortErrorCode, \"waiting for transaction to complete\"));\n    });\n    var CustomMap = Gu(this, \"error\", function (iterateEntries) {\n      Pu(value);\n      rejectPromise(generatorWrapper, iterateEntries.target);\n    });\n    var findEntry = this.setTimeoutWrapper;\n    return addToCallbackQueueWithoutContext(generatorWrapper, function () {\n      return findEntry;\n    });\n  };\n  setTimeoutWrapper.abort = function () {\n    this.entryIdCounter.abort();\n  };\n  setTimeoutWrapper.getAdEnvironment = function () {\n    TransactionRequest.executeGeneratorAsPromise.getAdEnvironment.call(this);\n    this.tasks.markAsCompleted();\n  };\n  var DatabaseRequest = function (generatorWrapper) {\n    AdEnvironmentConfig.call(this);\n    this.entryIdCounter = generatorWrapper;\n    this.tasks = new EventDispatcher(this);\n    this.tasks.window(this.entryIdCounter, \"abort\", bindOrWrapFunction(this.dispatchEvent, this, \"abort\"));\n    this.tasks.window(this.entryIdCounter, \"error\", this.xf);\n    this.tasks.window(this.entryIdCounter, \"versionchange\", this.filterAdProperties);\n    this.tasks.window(this.entryIdCounter, \"close\", bindOrWrapFunction(this.dispatchEvent, this, \"close\"));\n  };\n  inheritPrototype(DatabaseRequest, AdEnvironmentConfig);\n  setTimeoutWrapper = DatabaseRequest.prototype;\n  setTimeoutWrapper.undefinedVariable1 = true;\n  setTimeoutWrapper.xf = function (generatorWrapper) {\n    generatorWrapper = (generatorWrapper = generatorWrapper.target) && generatorWrapper.hasError;\n    this.dispatchEvent({\n      type: \"error\",\n      errorCode: generatorWrapper && generatorWrapper.severity\n    });\n  };\n  setTimeoutWrapper.filterAdProperties = function (generatorWrapper) {\n    this.dispatchEvent(new zB(generatorWrapper.oldVersion, generatorWrapper.newVersion));\n  };\n  setTimeoutWrapper.closeCache = function () {\n    if (this.undefinedVariable1) {\n      this.entryIdCounter.closeCache();\n      this.undefinedVariable1 = false;\n    }\n  };\n  setTimeoutWrapper.getUniqueId = function () {\n    return this.undefinedVariable1;\n  };\n  setTimeoutWrapper.getAdName = function () {\n    return this.entryIdCounter.name;\n  };\n  setTimeoutWrapper.getAdManifestVersion = function () {\n    return Number(this.entryIdCounter.version);\n  };\n  var AB = function (generatorWrapper) {\n    var value = [\"MediaSourceVideoChunk\"];\n    try {\n      var CustomMap = generatorWrapper.entryIdCounter.transaction(value, \"readwrite\");\n      return new TransactionRequest(CustomMap, generatorWrapper);\n    } catch (findEntry) {\n      throw createErrorFromException(findEntry, \"creating transaction\");\n    }\n  };\n  DatabaseRequest.prototype.getAdEnvironment = function () {\n    DatabaseRequest.executeGeneratorAsPromise.getAdEnvironment.call(this);\n    this.tasks.markAsCompleted();\n  };\n  var zB = function (generatorWrapper, value) {\n    AdEvent.call(this, \"versionchange\");\n    this.oldVersion = generatorWrapper;\n    this.newVersion = value;\n  };\n  inheritPrototype(zB, AdEvent);\n  var BB = function (generatorWrapper) {\n    var value = new Deferred();\n    if (undefined == ErrorBase) {\n      ErrorBase = globalScope.indexedDB || globalScope.mozIndexedDB || globalScope.webkitIndexedDB || globalScope.moz_indexedDB;\n    }\n    var CustomMap = ErrorBase.open(\"IndexedDbVideoChunkPersistentStorage\", 6);\n    CustomMap.onsuccess = function (findEntry) {\n      findEntry = new DatabaseRequest(findEntry.target.result);\n      value.resetGeneratorState(findEntry);\n    };\n    CustomMap.onerror = function (findEntry) {\n      rejectPromise(value, createErrorFromRequest(findEntry.target, \"opening database IndexedDbVideoChunkPersistentStorage\"));\n    };\n    CustomMap.onupgradeneeded = function (findEntry) {\n      if (generatorWrapper) {\n        var iterateEntries = new DatabaseRequest(findEntry.target.result);\n        generatorWrapper(new zB(findEntry.oldVersion, findEntry.newVersion), iterateEntries, new TransactionRequest(findEntry.target.transaction, iterateEntries));\n      }\n    };\n    CustomMap.onblocked = function () {};\n    return value;\n  };\n  var CB = function () {\n    AdEnvironmentConfig.apply(this, arguments);\n    this.entryIdCounter = null;\n  };\n  inheritPrototype(CB, AdEnvironmentConfig);\n  CB.prototype.initializeMraid = function () {\n    var generatorWrapper = this;\n    return Promise.resolve(BB(this.tasks)).then(function (value) {\n      generatorWrapper.entryIdCounter = value;\n    }, function (value) {\n      settlePromise(resolvePromise.getAdInstance(), \"codf\", value.message);\n    });\n  };\n  CB.prototype.getUniqueId = function () {\n    return this.entryIdCounter !== null && this.entryIdCounter.getUniqueId();\n  };\n  CB.prototype.closeCache = function () {\n    var generatorWrapper = this;\n    return new Promise(function (value) {\n      DB(generatorWrapper, value);\n    }).then(function () {\n      return EB();\n    }).then(function () {\n      generatorWrapper.entryIdCounter.closeCache();\n    });\n  };\n  var EB = function () {\n    var generatorWrapper;\n    if ((generatorWrapper = navigator.storage) == null ? 0 : generatorWrapper.estimate) {\n      return navigator.storage.estimate().then(function (value) {\n        settlePromise(resolvePromise.getAdInstance(), \"csue\", String(value.usage));\n      });\n    } else {\n      return Promise.resolve(undefined);\n    }\n  };\n  CB.prototype.containsElement = function (generatorWrapper) {\n    if (generatorWrapper = FB(generatorWrapper, 0)) {\n      return GB(this, HB(generatorWrapper), generatorWrapper.getBase64EncodedArray);\n    } else {\n      return Promise.resolve(null);\n    }\n  };\n  CB.prototype.isIpod = function (generatorWrapper, value, CustomMap, findEntry) {\n    if (value = FB(value, CustomMap)) {\n      CustomMap = value.startIndex;\n      deleteVideoChunk(this, {\n        PerformanceEvent: HB(value),\n        startIndex: CustomMap,\n        isAndroidBrowser: CustomMap + generatorWrapper.byteLength - 1,\n        getBase64EncodedArray: value.getBase64EncodedArray,\n        timestamp: new Date(Date.now()),\n        handleGeneratorError: findEntry,\n        includesBrand: value.includesBrand,\n        video: generatorWrapper\n      });\n    } else {\n      Promise.resolve(undefined);\n    }\n  };\n  CB.prototype.tasks = function (generatorWrapper, value) {\n    if (value.entryIdCounter.objectStoreNames.rectangleContains(\"MediaSourceVideoChunk\")) {\n      try {\n        value.entryIdCounter.deleteObjectStore(\"MediaSourceVideoChunk\");\n      } catch (findEntry) {\n        throw createErrorFromException(findEntry, \"deleting object store MediaSourceVideoChunk\");\n      }\n    }\n    generatorWrapper = {\n      keyPath: \"cacheId\"\n    };\n    try {\n      var CustomMap = new ObjectStoreRequest(value.entryIdCounter.createObjectStore(\"MediaSourceVideoChunk\", generatorWrapper));\n    } catch (findEntry) {\n      throw createErrorFromException(findEntry, \"creating object store MediaSourceVideoChunk\");\n    }\n    value = {\n      unique: false\n    };\n    try {\n      CustomMap.entryIdCounter.createIndex(\"timestamp\", \"timestamp\", value);\n    } catch (findEntry) {\n      throw createErrorFromException(findEntry, \"creating new index timestamp with key path timestamp\");\n    }\n  };\n  var DB = function (generatorWrapper, value) {\n    var CustomMap = new Date(Date.now());\n    CustomMap.setDate(CustomMap.getDate() - 30);\n    CustomMap = new KeyRangeWrapper(IndexedDBKeyRange.upperBound(CustomMap, undefined));\n    var findEntry = openIndexCursor(getIndexTimestamp(AB(generatorWrapper.entryIdCounter).objectStore(\"MediaSourceVideoChunk\")), CustomMap);\n    var iterateEntries = findEntry.window(\"n\", function () {\n      findEntry.removeElement();\n      findEntry.next();\n    });\n    Gu(findEntry, \"c\", function () {\n      Pu(iterateEntries);\n      value();\n    });\n  };\n  var FB = function (generatorWrapper, value) {\n    var CustomMap = new UriParameterManager(generatorWrapper);\n    generatorWrapper = CustomMap.getAdId();\n    var findEntry = getParameterById(CustomMap, \"itag\");\n    var iterateEntries = getParameterById(CustomMap, \"source\");\n    var createCircularNode = getParameterById(CustomMap, \"lmt\");\n    CustomMap = getRangeStart(CustomMap);\n    var entryIdCounter = [];\n    if (generatorWrapper) {\n      if (findEntry) {\n        if (iterateEntries) {\n          if (createCircularNode) {\n            if (CustomMap === null) {\n              entryIdCounter.push(\"startIndex\");\n            }\n          } else {\n            entryIdCounter.push(\"lmt\");\n          }\n        } else {\n          entryIdCounter.push(\"source\");\n        }\n      } else {\n        entryIdCounter.push(\"itag\");\n      }\n    } else {\n      entryIdCounter.push(\"videoId\");\n    }\n    if (entryIdCounter.length > 0) {\n      settlePromise(resolvePromise.getAdInstance(), \"civp\", entryIdCounter.join(\"-\"));\n      return null;\n    } else {\n      return {\n        getTrustedTypesPolicy: generatorWrapper,\n        includesBrand: findEntry,\n        source: iterateEntries,\n        getBase64EncodedArray: createCircularNode,\n        startIndex: CustomMap + value\n      };\n    }\n  };\n  var HB = function (generatorWrapper) {\n    for (var value = [generatorWrapper.getTrustedTypesPolicy, generatorWrapper.source, generatorWrapper.startIndex].join(), CustomMap = 0, findEntry = 0; findEntry < value.length; findEntry++) {\n      CustomMap = Math.imul(31, CustomMap) + value.charCodeAt(findEntry) | 0;\n    }\n    return CustomMap.toString() + \",\" + generatorWrapper.includesBrand;\n  };\n  var GB = function (generatorWrapper, value, CustomMap) {\n    var findEntry = AB(generatorWrapper.entryIdCounter).objectStore(\"MediaSourceVideoChunk\");\n    return Promise.resolve(findEntry.get(value)).then(function (iterateEntries) {\n      if (!iterateEntries) {\n        settlePromise(resolvePromise.getAdInstance(), \"cenf\", \"1\");\n        return null;\n      }\n      if (iterateEntries.getBase64EncodedArray !== CustomMap) {\n        settlePromise(resolvePromise.getAdInstance(), \"cdl\", \"1\");\n        findEntry.removeElement(value).then(null, function (createCircularNode) {\n          settlePromise(resolvePromise.getAdInstance(), \"crdlvf\", createCircularNode.message);\n        });\n        return null;\n      }\n      settlePromise(resolvePromise.getAdInstance(), \"cefml\", \"1\");\n      return {\n        includesBrand: iterateEntries.includesBrand,\n        isAndroidBrowser: iterateEntries.isAndroidBrowser,\n        handleGeneratorError: iterateEntries.handleGeneratorError,\n        video: iterateEntries.video\n      };\n    }, function (iterateEntries) {\n      settlePromise(resolvePromise.getAdInstance(), \"cgvf\", iterateEntries.message);\n      return null;\n    });\n  };\n  var deleteVideoChunk = function (generatorWrapper, value) {\n    generatorWrapper = AB(generatorWrapper.entryIdCounter).objectStore(\"MediaSourceVideoChunk\");\n    Promise.resolve(putValue(generatorWrapper, value)).then(function () {\n      settlePromise(resolvePromise.getAdInstance(), \"cavs\", \"1\");\n    }, function (CustomMap) {\n      settlePromise(resolvePromise.getAdInstance(), \"cavf\", CustomMap.message);\n    });\n  };\n  var VideoChunkLoader = function (generatorWrapper) {\n    MediaElement.call(this);\n    var value = this;\n    this.resolvePromise = this.tasks = this.entryIdCounter = 0;\n    this.handleAsync = this.logError = null;\n    this.uri = new table(generatorWrapper);\n    this.state = 0;\n    if (this.isDone = isSupportedEnvironment() && !isGCacheURL(this.uri)) {\n      this.setTimeoutWrapper = createInstanceWithArguments(CB);\n    } else {\n      this.setTimeoutWrapper = null;\n    }\n    executeOrDelayUntilDisposed(this, function () {\n      markAsCompletedWrapper(value.setTimeoutWrapper);\n    });\n    if (this.isDone) {\n      this.logError = this.setTimeoutWrapper.initializeMraid();\n    } else {\n      this.logError = null;\n    }\n  };\n  inheritPrototype(VideoChunkLoader, MediaElement);\n  VideoChunkLoader.prototype.dispatchUnhandledRejection = function () {\n    return this.entryIdCounter;\n  };\n  VideoChunkLoader.prototype.onFulfilled = function () {\n    return this.state === 3;\n  };\n  VideoChunkLoader.prototype.handleThenable = function (generatorWrapper) {\n    if (this.state === 1) {\n      this.entryIdCounter += generatorWrapper;\n      this.state = 2;\n    } else if (this.state === 0) {\n      this.entryIdCounter += generatorWrapper;\n      this.state = 1;\n      checkAndHandleLoadingState(this);\n    }\n  };\n  var checkAndHandleLoadingState = function (generatorWrapper) {\n    wrapGeneratorToPromise(function (value) {\n      if (value.entryIdCounter == 1) {\n        if (generatorWrapper.state === 2) {\n          generatorWrapper.state = 1;\n        }\n        return generatorYield(value, loadVideoChunk(generatorWrapper), 4);\n      }\n      var CustomMap = generatorWrapper.resolvePromise > 3;\n      if (CustomMap && generatorWrapper.handleAsync !== null) {\n        var findEntry = createCustomEvent(\"media_source_error\", {\n          code: generatorWrapper.tasks > 0 ? MediaError.MEDIA_ERR_NETWORK : MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED,\n          message: 'Response code \"' + generatorWrapper.handleAsync + '\" with ' + generatorWrapper.entryIdCounter + \" bytes requested and \" + generatorWrapper.tasks + \" bytes loaded\"\n        });\n        generatorWrapper.dispatchEvent(findEntry);\n      }\n      if (generatorWrapper.tasks < generatorWrapper.entryIdCounter && generatorWrapper.state !== 3 && !CustomMap) {\n        value.entryIdCounter = 1;\n      } else {\n        if (generatorWrapper.state !== 3) {\n          generatorWrapper.state = 0;\n        }\n        value.entryIdCounter = 0;\n      }\n    });\n  };\n  var loadVideoChunk = function (generatorWrapper) {\n    var value;\n    return wrapGeneratorToPromise(function (CustomMap) {\n      switch (CustomMap.entryIdCounter) {\n        case 1:\n          value = generatorWrapper.tasks + \"-\" + (generatorWrapper.entryIdCounter - 1);\n          setParameter(generatorWrapper.uri, \"range\", value);\n          if (!generatorWrapper.isDone) {\n            CustomMap.entryIdCounter = 2;\n            break;\n          }\n          return generatorYield(CustomMap, generatorWrapper.logError, 3);\n        case 3:\n          return CustomMap.return(loadVideoChunkFromCache(generatorWrapper));\n        case 2:\n          CustomMap.setTimeoutWrapper = 4;\n          return generatorYield(CustomMap, loadVideoChunkViaXHR(generatorWrapper), 6);\n        case 6:\n          resetGeneratorState(CustomMap);\n          break;\n        case 4:\n          getGeneratorException(CustomMap);\n          handleFallbackAndIncrementRetry(generatorWrapper);\n          CustomMap.entryIdCounter = 0;\n      }\n    });\n  };\n  var loadVideoChunkFromCache = function (generatorWrapper) {\n    var value;\n    return wrapGeneratorToPromise(function (CustomMap) {\n      switch (CustomMap.entryIdCounter) {\n        case 1:\n          return generatorYield(CustomMap, generatorWrapper.setTimeoutWrapper.containsElement(generatorWrapper.uri), 2);\n        case 2:\n          if (value = CustomMap.tasks) {\n            if (value.handleGeneratorError) {\n              generatorWrapper.state = 3;\n            }\n            processVideoChunkData(generatorWrapper, value.video, 0);\n            CustomMap.entryIdCounter = 0;\n            break;\n          }\n          CustomMap.setTimeoutWrapper = 4;\n          return generatorYield(CustomMap, loadVideoChunkViaXHR(generatorWrapper), 6);\n        case 6:\n          resetGeneratorState(CustomMap);\n          break;\n        case 4:\n          getGeneratorException(CustomMap);\n          handleFallbackAndIncrementRetry(generatorWrapper);\n          CustomMap.entryIdCounter = 0;\n      }\n    });\n  };\n  var handleFallbackAndIncrementRetry = function (generatorWrapper) {\n    if (handleThenable(Lm)) {\n      generatorWrapper: {\n        var value = new UriParameterManager(generatorWrapper.uri);\n        var CustomMap, findEntry;\n        if ((CustomMap = value.uri) == null ? 0 : (findEntry = CustomMap.setTimeoutWrapper) == null ? 0 : findEntry.startsWith(\"/videoplayback\")) {\n          var iterateEntries = (CustomMap = getParameterById(value, \"mn\")) ? CustomMap.split(\",\") : null;\n          findEntry = getParameterById(value, \"fvip\");\n          CustomMap = value.uri.handleThenable();\n          if (iterateEntries && findEntry) {\n            var createCircularNode = (Number(getParameterById(value, \"fallback_count\")) || 0) + 1;\n            if (iterateEntries = iterateEntries[createCircularNode]) {\n              CustomMap.tasks = \"r\" + findEntry + \"---\" + iterateEntries + \".googlevideo.com\";\n              setParameter(CustomMap, \"fallback_count\", createCircularNode);\n              value = CustomMap;\n              break generatorWrapper;\n            }\n          }\n          var entryIdCounter, key;\n          findEntry = Number(((key = (entryIdCounter = CustomMap.entryIdCounter.get(\"cmo\")) == null ? undefined : entryIdCounter.split(\"=\")) != null ? key : [])[1]) || 0;\n          if (value.uri.tasks.match(/^r{1,2}(\\d+)---(.+)\\.googlevideo.com$/)) {\n            CustomMap.tasks = \"redirector.googlevideo.com\";\n          }\n          setParameter(CustomMap, \"cmo\", \"pf=\" + (findEntry + 1));\n          value = CustomMap;\n        } else {\n          value = value.uri;\n        }\n      }\n      generatorWrapper.uri = value;\n      generatorWrapper.dispatchEvent(createCustomEvent(\"bandaid_fallback_count\"));\n    }\n    generatorWrapper.resolvePromise++;\n  };\n  var loadVideoChunkVia"