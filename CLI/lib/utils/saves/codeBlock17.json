"ratorWrapper.altKey;\n    this.shiftKey = generatorWrapper.shiftKey;\n    this.metaKey = generatorWrapper.metaKey;\n    this.pointerId = generatorWrapper.pointerId || 0;\n    if (typeof generatorWrapper.pointerType === \"string\") {\n      this.pointerType = generatorWrapper.pointerType;\n    } else {\n      this.pointerType = pointerTypeMap[generatorWrapper.pointerType] || \"\";\n    }\n    this.state = generatorWrapper.state;\n    this.entryIdCounter = generatorWrapper;\n    if (generatorWrapper.defaultPrevented) {\n      TouchEventProcessor.executeGeneratorAsPromise.preventDefault.call(this);\n    }\n  };\n  TouchEventProcessor.prototype.stopPropagation = function () {\n    TouchEventProcessor.executeGeneratorAsPromise.stopPropagation.call(this);\n    if (this.entryIdCounter.stopPropagation) {\n      this.entryIdCounter.stopPropagation();\n    } else {\n      this.entryIdCounter.cancelBubble = true;\n    }\n  };\n  TouchEventProcessor.prototype.preventDefault = function () {\n    TouchEventProcessor.executeGeneratorAsPromise.preventDefault.call(this);\n    var generatorWrapper = this.entryIdCounter;\n    if (generatorWrapper.preventDefault) {\n      generatorWrapper.preventDefault();\n    } else {\n      generatorWrapper.returnValue = false;\n    }\n  };\n  var isListenableKey = \"closure_listenable_\" + (1000000 * Math.random() | 0);\n  var isListenable = function (generatorWrapper) {\n    return !(!generatorWrapper || !generatorWrapper[isListenableKey]);\n  };\n  var listenerUniqueId = 0;\n  var Listener = function (generatorWrapper, value, CustomMap, findEntry, iterateEntries) {\n    this.listener = generatorWrapper;\n    this.proxy = null;\n    this.src = value;\n    this.type = CustomMap;\n    this.capture = !!findEntry;\n    this.initializeBase64Encoding = iterateEntries;\n    this.key = ++listenerUniqueId;\n    this.tryNoopFunction = this.browserVersion = false;\n  };\n  var clearListener = function (generatorWrapper) {\n    generatorWrapper.tryNoopFunction = true;\n    generatorWrapper.listener = null;\n    generatorWrapper.proxy = null;\n    generatorWrapper.src = null;\n    generatorWrapper.initializeBase64Encoding = null;\n  };\n  var EventTarget = function (generatorWrapper) {\n    this.src = generatorWrapper;\n    this.entryIdCounter = {};\n    this.tasks = 0;\n  };\n  EventTarget.prototype.addParameter = function (generatorWrapper, value, CustomMap, findEntry, iterateEntries) {\n    var createCircularNode = generatorWrapper.toString();\n    generatorWrapper = this.entryIdCounter[createCircularNode];\n    if (!generatorWrapper) {\n      generatorWrapper = this.entryIdCounter[createCircularNode] = [];\n      this.tasks++;\n    }\n    var entryIdCounter = Bu(generatorWrapper, value, findEntry, iterateEntries);\n    if (-1 < entryIdCounter) {\n      value = generatorWrapper[entryIdCounter];\n      if (!CustomMap) {\n        value.browserVersion = false;\n      }\n    } else {\n      value = new Listener(value, this.src, createCircularNode, !!findEntry, iterateEntries);\n      value.browserVersion = CustomMap;\n      generatorWrapper.push(value);\n    }\n    return value;\n  };\n  EventTarget.prototype.removeElement = function (generatorWrapper, value, CustomMap, findEntry) {\n    generatorWrapper = generatorWrapper.toString();\n    if (!(generatorWrapper in this.entryIdCounter)) {\n      return false;\n    }\n    var iterateEntries = this.entryIdCounter[generatorWrapper];\n    value = Bu(iterateEntries, value, CustomMap, findEntry);\n    if (-1 < value) {\n      clearListener(iterateEntries[value]);\n      removeElementAtIndex(iterateEntries, value);\n      if (iterateEntries.length == 0) {\n        delete this.entryIdCounter[generatorWrapper];\n        this.tasks--;\n      }\n      return true;\n    } else {\n      return false;\n    }\n  };\n  var Cu = function (generatorWrapper, value) {\n    var CustomMap = value.type;\n    if (CustomMap in generatorWrapper.entryIdCounter && removeElement(generatorWrapper.entryIdCounter[CustomMap], value)) {\n      clearListener(value);\n      if (generatorWrapper.entryIdCounter[CustomMap].length == 0) {\n        delete generatorWrapper.entryIdCounter[CustomMap];\n        generatorWrapper.tasks--;\n      }\n    }\n  };\n  EventTarget.prototype.findLastElementIndex = function (generatorWrapper, value, CustomMap, findEntry) {\n    generatorWrapper = this.entryIdCounter[generatorWrapper.toString()];\n    var iterateEntries = -1;\n    if (generatorWrapper) {\n      iterateEntries = Bu(generatorWrapper, value, CustomMap, findEntry);\n    }\n    if (-1 < iterateEntries) {\n      return generatorWrapper[iterateEntries];\n    } else {\n      return null;\n    }\n  };\n  var Bu = function (generatorWrapper, value, CustomMap, findEntry) {\n    for (var iterateEntries = 0; iterateEntries < generatorWrapper.length; ++iterateEntries) {\n      var createCircularNode = generatorWrapper[iterateEntries];\n      if (!createCircularNode.tryNoopFunction && createCircularNode.listener == value && createCircularNode.capture == !!CustomMap && createCircularNode.initializeBase64Encoding == findEntry) {\n        return iterateEntries;\n      }\n    }\n    return -1;\n  };\n  var Du = \"closure_lm_\" + (1000000 * Math.random() | 0);\n  var Eu = {};\n  var Fu = 0;\n  var addPageHideListener = function (generatorWrapper, value, CustomMap, findEntry, iterateEntries) {\n    if (findEntry && findEntry.once) {\n      return Gu(generatorWrapper, value, CustomMap, findEntry, iterateEntries);\n    }\n    if (Array.isArray(value)) {\n      for (var createCircularNode = 0; createCircularNode < value.length; createCircularNode++) {\n        addPageHideListener(generatorWrapper, value[createCircularNode], CustomMap, findEntry, iterateEntries);\n      }\n      return null;\n    }\n    CustomMap = Iu(CustomMap);\n    if (isListenable(generatorWrapper)) {\n      return generatorWrapper.window(value, CustomMap, isObjectOrFunction(findEntry) ? !!findEntry.capture : !!findEntry, iterateEntries);\n    } else {\n      return Ju(generatorWrapper, value, CustomMap, false, findEntry, iterateEntries);\n    }\n  };\n  var Ju = function (generatorWrapper, value, CustomMap, findEntry, iterateEntries, createCircularNode) {\n    if (!value) {\n      throw Error(\"Invalid event type\");\n    }\n    var entryIdCounter = isObjectOrFunction(iterateEntries) ? !!iterateEntries.capture : !!iterateEntries;\n    var key = Ku(generatorWrapper);\n    if (!key) {\n      generatorWrapper[Du] = key = new EventTarget(generatorWrapper);\n    }\n    CustomMap = key.addParameter(value, CustomMap, findEntry, entryIdCounter, createCircularNode);\n    if (CustomMap.proxy) {\n      return CustomMap;\n    }\n    findEntry = Lu();\n    CustomMap.proxy = findEntry;\n    findEntry.src = generatorWrapper;\n    findEntry.listener = CustomMap;\n    if (generatorWrapper.addEventListener) {\n      if (!isPassiveEventSupported) {\n        iterateEntries = entryIdCounter;\n      }\n      if (undefined === iterateEntries) {\n        iterateEntries = false;\n      }\n      generatorWrapper.addEventListener(value.toString(), findEntry, iterateEntries);\n    } else if (generatorWrapper.attachEvent) {\n      generatorWrapper.attachEvent(Mu(value.toString()), findEntry);\n    } else if (generatorWrapper.addListener && generatorWrapper.removeListener) {\n      generatorWrapper.addListener(findEntry);\n    } else {\n      throw Error(\"addEventListener and attachEvent are unavailable.\");\n    }\n    Fu++;\n    return CustomMap;\n  };\n  var Lu = function () {\n    var generatorWrapper = Nu;\n    var value = function (CustomMap) {\n      return generatorWrapper.call(value.src, value.listener, CustomMap);\n    };\n    return value;\n  };\n  var Gu = function (generatorWrapper, value, CustomMap, findEntry, iterateEntries) {\n    if (Array.isArray(value)) {\n      for (var createCircularNode = 0; createCircularNode < value.length; createCircularNode++) {\n        Gu(generatorWrapper, value[createCircularNode], CustomMap, findEntry, iterateEntries);\n      }\n      return null;\n    }\n    CustomMap = Iu(CustomMap);\n    if (isListenable(generatorWrapper)) {\n      return generatorWrapper.sortArray(value, CustomMap, isObjectOrFunction(findEntry) ? !!findEntry.capture : !!findEntry, iterateEntries);\n    } else {\n      return Ju(generatorWrapper, value, CustomMap, true, findEntry, iterateEntries);\n    }\n  };\n  var Ou = function (generatorWrapper, value, CustomMap, findEntry, iterateEntries) {\n    if (Array.isArray(value)) {\n      for (var createCircularNode = 0; createCircularNode < value.length; createCircularNode++) {\n        Ou(generatorWrapper, value[createCircularNode], CustomMap, findEntry, iterateEntries);\n      }\n    } else {\n      if (isObjectOrFunction(findEntry)) {\n        findEntry = !!findEntry.capture;\n      } else {\n        findEntry = !!findEntry;\n      }\n      CustomMap = Iu(CustomMap);\n      if (isListenable(generatorWrapper)) {\n        generatorWrapper.compareValues(value, CustomMap, findEntry, iterateEntries);\n      } else if (generatorWrapper && (generatorWrapper = Ku(generatorWrapper)) && (value = generatorWrapper.findLastElementIndex(value, CustomMap, findEntry, iterateEntries))) {\n        Pu(value);\n      }\n    }\n  };\n  var Pu = function (generatorWrapper) {\n    if (typeof generatorWrapper !== \"number\" && generatorWrapper && !generatorWrapper.tryNoopFunction) {\n      var value = generatorWrapper.src;\n      if (isListenable(value)) {\n        Cu(value.createDeferred, generatorWrapper);\n      } else {\n        var CustomMap = generatorWrapper.type;\n        var findEntry = generatorWrapper.proxy;\n        if (value.removeEventListener) {\n          value.removeEventListener(CustomMap, findEntry, generatorWrapper.capture);\n        } else if (value.detachEvent) {\n          value.detachEvent(Mu(CustomMap), findEntry);\n        } else if (value.addListener && value.removeListener) {\n          value.removeListener(findEntry);\n        }\n        Fu--;\n        if (CustomMap = Ku(value)) {\n          Cu(CustomMap, generatorWrapper);\n          if (CustomMap.tasks == 0) {\n            CustomMap.src = null;\n            value[Du] = null;\n          }\n        } else {\n          clearListener(generatorWrapper);\n        }\n      }\n    }\n  };\n  var Mu = function (generatorWrapper) {\n    if (generatorWrapper in Eu) {\n      return Eu[generatorWrapper];\n    } else {\n      return Eu[generatorWrapper] = \"on\" + generatorWrapper;\n    }\n  };\n  var Nu = function (generatorWrapper, value) {\n    if (generatorWrapper.tryNoopFunction) {\n      generatorWrapper = true;\n    } else {\n      value = new TouchEventProcessor(value, this);\n      var CustomMap = generatorWrapper.listener;\n      var findEntry = generatorWrapper.initializeBase64Encoding || generatorWrapper.src;\n      if (generatorWrapper.browserVersion) {\n        Pu(generatorWrapper);\n      }\n      generatorWrapper = CustomMap.call(findEntry, value);\n    }\n    return generatorWrapper;\n  };\n  var Ku = function (generatorWrapper) {\n    generatorWrapper = generatorWrapper[Du];\n    if (generatorWrapper instanceof EventTarget) {\n      return generatorWrapper;\n    } else {\n      return null;\n    }\n  };\n  var Qu = \"__closure_events_fn_\" + (1000000000 * Math.random() >>> 0);\n  var Iu = function (generatorWrapper) {\n    if (typeof generatorWrapper === \"function\") {\n      return generatorWrapper;\n    }\n    if (!generatorWrapper[Qu]) {\n      generatorWrapper[Qu] = function (value) {\n        return generatorWrapper.handleEvent(value);\n      };\n    }\n    return generatorWrapper[Qu];\n  };\n  var AdEnvironmentConfig = function () {\n    tryCall.call(this);\n    this.createDeferred = new EventTarget(this);\n    this.isFirefox = this;\n    this.firstQuartileTime = null;\n  };\n  inheritPrototype(AdEnvironmentConfig, tryCall);\n  AdEnvironmentConfig.prototype[isListenableKey] = true;\n  setTimeoutWrapper = AdEnvironmentConfig.prototype;\n  setTimeoutWrapper.addEventListener = function (generatorWrapper, value, CustomMap, findEntry) {\n    addPageHideListener(this, generatorWrapper, value, CustomMap, findEntry);\n  };\n  setTimeoutWrapper.removeEventListener = function (generatorWrapper, value, CustomMap, findEntry) {\n    Ou(this, generatorWrapper, value, CustomMap, findEntry);\n  };\n  setTimeoutWrapper.dispatchEvent = function (generatorWrapper) {\n    var value,\n      CustomMap = this.firstQuartileTime;\n    if (CustomMap) {\n      for (value = []; CustomMap; CustomMap = CustomMap.firstQuartileTime) {\n        value.push(CustomMap);\n      }\n    }\n    CustomMap = this.isFirefox;\n    var findEntry = generatorWrapper.type || generatorWrapper;\n    if (typeof generatorWrapper === \"string\") {\n      generatorWrapper = new AdEvent(generatorWrapper, CustomMap);\n    } else if (generatorWrapper instanceof AdEvent) {\n      generatorWrapper.target = generatorWrapper.target || CustomMap;\n    } else {\n      var iterateEntries = generatorWrapper;\n      generatorWrapper = new AdEvent(findEntry, CustomMap);\n      extendObject(generatorWrapper, iterateEntries);\n    }\n    iterateEntries = true;\n    if (value) {\n      for (var createCircularNode = value.length - 1; !generatorWrapper.tasks && createCircularNode >= 0; createCircularNode--) {\n        var entryIdCounter = generatorWrapper.currentTarget = value[createCircularNode];\n        iterateEntries = executeListeners(entryIdCounter, findEntry, true, generatorWrapper) && iterateEntries;\n      }\n    }\n    if (!generatorWrapper.tasks) {\n      entryIdCounter = generatorWrapper.currentTarget = CustomMap;\n      iterateEntries = executeListeners(entryIdCounter, findEntry, true, generatorWrapper) && iterateEntries;\n      if (!generatorWrapper.tasks) {\n        iterateEntries = executeListeners(entryIdCounter, findEntry, false, generatorWrapper) && iterateEntries;\n      }\n    }\n    if (value) {\n      for (createCircularNode = 0; !generatorWrapper.tasks && createCircularNode < value.length; createCircularNode++) {\n        entryIdCounter = generatorWrapper.currentTarget = value[createCircularNode];\n        iterateEntries = executeListeners(entryIdCounter, findEntry, false, generatorWrapper) && iterateEntries;\n      }\n    }\n    return iterateEntries;\n  };\n  setTimeoutWrapper.getAdEnvironment = function () {\n    AdEnvironmentConfig.executeGeneratorAsPromise.getAdEnvironment.call(this);\n    if (this.createDeferred) {\n      var CustomMap;\n      var generatorWrapper = this.createDeferred;\n      var value = 0;\n      for (CustomMap in generatorWrapper.entryIdCounter) {\n        for (var findEntry = generatorWrapper.entryIdCounter[CustomMap], iterateEntries = 0; iterateEntries < findEntry.length; iterateEntries++) {\n          ++value;\n          clearListener(findEntry[iterateEntries]);\n        }\n        delete generatorWrapper.entryIdCounter[CustomMap];\n        generatorWrapper.tasks--;\n      }\n    }\n    this.firstQuartileTime = null;\n  };\n  setTimeoutWrapper.window = function (generatorWrapper, value, CustomMap, findEntry) {\n    return this.createDeferred.addParameter(String(generatorWrapper), value, false, CustomMap, findEntry);\n  };\n  setTimeoutWrapper.sortArray = function (generatorWrapper, value, CustomMap, findEntry) {\n    return this.createDeferred.addParameter(String(generatorWrapper), value, true, CustomMap, findEntry);\n  };\n  setTimeoutWrapper.compareValues = function (generatorWrapper, value, CustomMap, findEntry) {\n    this.createDeferred.removeElement(String(generatorWrapper), value, CustomMap, findEntry);\n  };\n  var executeListeners = function (generatorWrapper, value, CustomMap, findEntry) {\n    value = generatorWrapper.createDeferred.entryIdCounter[String(value)];\n    if (!value) {\n      return true;\n    }\n    value = value.concat();\n    for (var iterateEntries = true, createCircularNode = 0; createCircularNode < value.length; ++createCircularNode) {\n      var entryIdCounter = value[createCircularNode];\n      if (entryIdCounter && !entryIdCounter.tryNoopFunction && entryIdCounter.capture == CustomMap) {\n        var key = entryIdCounter.listener;\n        var value = entryIdCounter.initializeBase64Encoding || entryIdCounter.src;\n        if (entryIdCounter.browserVersion) {\n          Cu(generatorWrapper.createDeferred, entryIdCounter);\n        }\n        iterateEntries = key.call(value, findEntry) !== false && iterateEntries;\n      }\n    }\n    return iterateEntries && !findEntry.defaultPrevented;\n  };\n  AdEnvironmentConfig.prototype.findLastElementIndex = function (generatorWrapper, value, CustomMap, findEntry) {\n    return this.createDeferred.findLastElementIndex(String(generatorWrapper), value, CustomMap, findEntry);\n  };\n  var ObjectPool = function (generatorWrapper, value) {\n    this.setTimeoutWrapper = generatorWrapper;\n    this.createDeferred = value;\n    this.tasks = 0;\n    this.entryIdCounter = null;\n  };\n  ObjectPool.prototype.get = function () {\n    if (this.tasks > 0) {\n      this.tasks--;\n      var generatorWrapper = this.entryIdCounter;\n      this.entryIdCounter = generatorWrapper.next;\n      generatorWrapper.next = null;\n    } else {\n      generatorWrapper = this.setTimeoutWrapper();\n    }\n    return generatorWrapper;\n  };\n  var releaseObject = function (generatorWrapper, value) {\n    generatorWrapper.createDeferred(value);\n    if (generatorWrapper.tasks < 100) {\n      generatorWrapper.tasks++;\n      value.next = generatorWrapper.entryIdCounter;\n      generatorWrapper.entryIdCounter = value;\n    }\n  };\n  var Uu,\n    getMessageChannelMethod = function () {\n      var generatorWrapper = globalScope.MessageChannel;\n      if (typeof generatorWrapper === \"undefined\" && typeof window !== \"undefined\" && window.sendPostMessage && window.addEventListener && !handleAsync(\"Presto\")) {\n        generatorWrapper = function () {\n          var iterateEntries = createElement(document, \"IFRAME\");\n          iterateEntries.style.display = \"none\";\n          document.documentElement.appendChild(iterateEntries);\n          var createCircularNode = iterateEntries.contentWindow;\n          iterateEntries = createCircularNode.document;\n          iterateEntries.open();\n          iterateEntries.closeCache();\n          var entryIdCounter = \"callImmediate\" + Math.random();\n          var key = createCircularNode.location.protocol == \"file:\" ? \"*\" : createCircularNode.location.protocol + \"//\" + createCircularNode.location.host;\n          iterateEntries = bindOrWrapFunction(function (value) {\n            if ((key == \"*\" || value.origin == key) && value.data == entryIdCounter) {\n              this.port1.onmessage();\n            }\n          }, this);\n          createCircularNode.addEventListener(\"message\", iterateEntries, false);\n          this.port1 = {};\n          this.port2 = {\n            sendPostMessage() {\n              createCircularNode.sendPostMessage(entryIdCounter, key);\n            }\n          };\n        };\n      }\n      if (typeof generatorWrapper !== \"undefined\") {\n        var value = new generatorWrapper();\n        var CustomMap = {};\n        var findEntry = CustomMap;\n        value.port1.onmessage = function () {\n          if (undefined !== CustomMap.next) {\n            CustomMap = CustomMap.next;\n            var iterateEntries = CustomMap.createInstanceWithTemporaryData;\n            CustomMap.createInstanceWithTemporaryData = null;\n            iterateEntries();\n          }\n        };\n        return function (iterateEntries) {\n          findEntry.next = {\n            createInstanceWithTemporaryData: iterateEntries\n          };\n          findEntry = findEntry.next;\n          value.port2.sendPostMessage(0);\n        };\n      }\n      return function (iterateEntries) {\n        globalScope.setTimeout(iterateEntries, 0);\n      };\n    };\n  var TaskQueue = function () {\n    this.tasks = this.entryIdCounter = null;\n  };\n  TaskQueue.prototype.addParameter = function (generatorWrapper, value) {\n    var CustomMap = taskQueuePool.get();\n    CustomMap.set(generatorWrapper, value);\n    if (this.tasks) {\n      this.tasks.next = CustomMap;\n    } else {\n      this.entryIdCounter = CustomMap;\n    }\n    this.tasks = CustomMap;\n  };\n  TaskQueue.prototype.removeElement = function () {\n    var generatorWrapper = null;\n    if (this.entryIdCounter) {\n      generatorWrapper = this.entryIdCounter;\n      this.entryIdCounter = this.entryIdCounter.next;\n      if (!this.entryIdCounter) {\n        this.tasks = null;\n      }\n      generatorWrapper.next = null;\n    }\n    return generatorWrapper;\n  };\n  var taskQueuePool = new ObjectPool(function () {\n    return new TaskQueueNode();\n  }, function (generatorWrapper) {\n    return generatorWrapper.resetAdStateController();\n  });\n  var TaskQueueNode = function () {\n    this.next = this.entryIdCounter = this.tasks = null;\n  };\n  TaskQueueNode.prototype.set = function (generatorWrapper, value) {\n    this.tasks = generatorWrapper;\n    this.entryIdCounter = value;\n    this.next = null;\n  };\n  TaskQueueNode.prototype.resetAdStateController = function () {\n    this.next = this.entryIdCounter = this.tasks = null;\n  };\n  var executeTasksMethod;\n  var tasksExecuted = false;\n  var globalTaskQueue = new TaskQueue();\n  var enqueueTask = function (generatorWrapper, value) {\n    if (!executeTasksMethod) {\n      setupExecuteTasksMethod();\n    }\n    if (!tasksExecuted) {\n      executeTasksMethod();\n      tasksExecuted = true;\n    }\n    globalTaskQueue.addParameter(generatorWrapper, value);\n  };\n  var setupExecuteTasksMethod = function () {\n    if (globalScope.Promise && globalScope.Promise.resolve) {\n      var generatorWrapper = globalScope.Promise.resolve(undefined);\n      executeTasksMethod = function () {\n        generatorWrapper.then(executeQueuedTasks);\n      };\n    } else {\n      executeTasksMethod = function () {\n        var value = executeQueuedTasks;\n        if (typeof globalScope.setImmediate !== \"function\" || globalScope.Window && globalScope.Window.prototype && globalScope.Window.prototype.setImmediate == globalScope.setImmediate) {\n          if (!Uu) {\n            Uu = getMessageChannelMethod();\n          }\n          Uu(value);\n        } else {\n          globalScope.setImmediate(value);\n        }\n      };\n    }\n  };\n  var executeQueuedTasks = function () {\n    for (var generatorWrapper; generatorWrapper = globalTaskQueue.removeElement();) {\n      try {\n        generatorWrapper.tasks.call(generatorWrapper.entryIdCounter);\n      } catch (value) {\n        deferError(value);\n      }\n      releaseObject(taskQueuePool, generatorWrapper);\n    }\n    tasksExecuted = false;\n  };\n  var isThenable = function (generatorWrapper) {\n    if (!generatorWrapper) {\n      return false;\n    }\n    try {\n      return !!generatorWrapper.$goog_Thenable;\n    } catch (value) {\n      return false;\n    }\n  };\n  var PromisePolyfill = function (generatorWrapper) {\n    this.entryIdCounter = 0;\n    this.onFulfilled = undefined;\n    this.createDeferred = this.tasks = this.setTimeoutWrapper = null;\n    this.handleAsync = this.isDone = false;\n    if (generatorWrapper != noopFunction) {\n      try {\n        var value = this;\n        generatorWrapper.call(undefined, function (CustomMap) {\n          resolveOrReject(value, 2, CustomMap);\n        }, function (CustomMap) {\n          resolveOrReject(value, 3, CustomMap);\n        });\n      } catch (CustomMap) {\n        resolveOrReject(this, 3, CustomMap);\n      }\n    }\n  };\n  var PromiseChainNode = function () {\n    this.next = this.context = this.tasks = this.setTimeoutWrapper = this.entryIdCounter = null;\n    this.createDeferred = false;\n  };\n  PromiseChainNode.prototype.resetAdStateController = function () {\n    this.context = this.tasks = this.setTimeoutWrapper = this.entryIdCounter = null;\n    this.createDeferred = false;\n  };\n  var promiseChainNodePool = new ObjectPool(function () {\n    return new PromiseChainNode();\n  }, function (generatorWrapper) {\n    generatorWrapper.resetAdStateController();\n  });\n  var createPromiseChainNode = function (generatorWrapper, value, CustomMap) {\n    var findEntry = promiseChainNodePool.get();\n    findEntry.setTimeoutWrapper = generatorWrapper;\n    findEntry.tasks = value;\n    findEntry.context = CustomMap;\n    return findEntry;\n  };\n  PromisePolyfill.prototype.then = function (generatorWrapper, value, CustomMap) {\n    return thenHelper(this, typeof generatorWrapper === \"function\" ? generatorWrapper : null, typeof value === \"function\" ? value : null, CustomMap);\n  };\n  PromisePolyfill.prototype.$goog_Thenable = true;\n  PromisePolyfill.prototype.settlePromise = function (generatorWrapper, value) {\n    return thenHelper(this, null, generatorWrapper, value);\n  };\n  PromisePolyfill.prototype.catch = PromisePolyfill.prototype.settlePromise;\n  PromisePolyfill.prototype.cancel = function (generatorWrapper) {\n    if (this.entryIdCounter == 0) {\n      var value = new CancellationError(generatorWrapper);\n      enqueueTask(function () {\n        mediaVersion(this, value);\n      }, this);\n    }\n  };\n  var mediaVersion = function (generatorWrapper, value) {\n    if (generatorWrapper.entryIdCounter == 0) {\n      if (generatorWrapper.setTimeoutWrapper) {\n        var CustomMap = generatorWrapper.setTimeoutWrapper;\n        if (CustomMap.tasks) {\n          for (var findEntry = 0, iterateEntries = null, createCircularNode = null, entryIdCounter = CustomMap.tasks; entryIdCounter && (entryIdCounter.createDeferred || (findEntry++, entryIdCounter.entryIdCounter == generatorWrapper && (iterateEntries = entryIdCounter), !(iterateEntries && findEntry > 1))); entryIdCounter = entryIdCounter.next) {\n            if (!iterateEntries) {\n              createCircularNode = entryIdCounter;\n            }\n          }\n          if (iterateEntries) {\n            if (CustomMap.entryIdCounter == 0 && findEntry == 1) {\n              mediaVersion(CustomMap, value);\n            } else {\n              if (createCircularNode) {\n                findEntry = createCircularNode;\n                if (findEntry.next == CustomMap.createDeferred) {\n                  CustomMap.createDeferred = findEntry;\n                }\n                findEntry.next = findEntry.next.next;\n              } else {\n                networkVersion(CustomMap);\n              }\n              rejectPromiseChainNode(CustomMap, iterateEntries, 3, value);\n            }\n          }\n        }\n        generatorWrapper.setTimeoutWrapper = null;\n      } else {\n        resolveOrReject(generatorWrapper, 3, value);\n      }\n    }\n  };\n  var appendPromiseChainNode = function (generatorWrapper, value) {\n    if (!(generatorWrapper.tasks || generatorWrapper.entryIdCounter != 2 && generatorWrapper.entryIdCounter != 3)) {\n      finalizePromise(generatorWrapper);\n    }\n    if (generatorWrapper.createDeferred) {\n      generatorWrapper.createDeferred.next = value;\n    } else {\n      generatorWrapper.tasks = value;\n    }\n    generatorWrapper.createDeferred = value;\n  };\n  var thenHelper = function (generatorWrapper, value, CustomMap, findEntry) {\n    var iterateEntries = createPromiseChainNode(null, null, null);\n    iterateEntries.entryIdCounter = new PromisePolyfill(function (createCircularNode, entryIdCounter) {\n      if (value) {\n        iterateEntries.setTimeoutWrapper = function (key) {\n          try {\n            var value = value.call(findEntry, key);\n            createCircularNode(value);\n          } catch (entry) {\n            entryIdCounter(entry);\n          }\n        };\n      } else {\n        iterateEntries.setTimeoutWrapper = createCircularNode;\n      }\n      if (CustomMap) {\n        iterateEntries.tasks = function (key) {\n          try {\n            var value = CustomMap.call(findEntry, key);\n            if (undefined === value && key instanceof CancellationError) {\n              entryIdCounter(key);\n            } else {\n              createCircularNode(value);\n            }\n          } catch (entry) {\n            entryIdCounter(entry);\n          }\n        };\n      } else {\n        iterateEntries.tasks = entryIdCounter;\n      }\n    });\n    iterateEntries.entryIdCounter.setTimeoutWrapper = generatorWrapper;\n    appendPromiseChainNode(generatorWrapper, iterateEntries);\n    return iterateEntries.entryIdCounter;\n  };\n  PromisePolyfill.prototype.dispatchUnhandledRejection = function (generatorWrapper) {\n    this.entryIdCounter = 0;\n    resolveOrReject(this, 2, generatorWrapper);\n  };\n  PromisePolyfill.prototype.handleThenable = function (generatorWrapper) {\n    this.entryIdCounter = 0;\n    resolveOrReject(this, 3, generatorWrapper);\n  };\n  var resolveOrReject = function (generatorWrapper, value, CustomMap) {\n    if (generatorWrapper.entryIdCounter == 0) {\n      if (generatorWrapper === CustomMap) {\n        value = 3;\n        CustomMap = new TypeError(\"Promise cannot resolve to itself\");\n      }\n      generatorWrapper.entryIdCounter = 1;\n      generatorWrapper: {\n        var findEntry = CustomMap;\n        var iterateEntries = generatorWrapper.dispatchUnhandledRejection;\n        var createCircularNode = generatorWrapper.handleThenable;\n        if (findEntry instanceof PromisePolyfill) {\n          appendPromiseChainNode(findEntry, createPromiseChainNode(iterateEntries || noopFunction, createCircularNode || null, generatorWrapper));\n          var entryIdCounter = true;\n        } else if (isThenable(findEntry)) {\n          findEntry.then(iterateEntries, createCircularNode, generatorWrapper);\n          entryIdCounter = true;\n        } else {\n          if (isObjectOrFunction(findEntry)) {\n            try {\n              var key = findEntry.then;\n              if (typeof key === \"function\") {\n                handleThenable(findEntry, key, iterateEntries, createCircularNode, generatorWrapper);\n                entryIdCounter = true;\n                break generatorWrapper;\n              }\n            } catch (value) {\n              createCircularNode.call(generatorWrapper, value);\n              entryIdCounter = true;\n              break generatorWrapper;\n            }\n          }\n          entryIdCounter = false;\n        }\n      }\n      if (!entryIdCounter) {\n        generatorWrapper.onFulfilled = CustomMap;\n        generatorWrapper.entryIdCounter = value;\n        generatorWrapper.setTimeoutWrapper = null;\n        finalizePromise(generatorWrapper);\n        if (!(value != 3 || CustomMap instanceof CancellationError)) {\n          reportUnhandledRejection(generatorWrapper, CustomMap);\n        }\n      }\n    }\n  };\n  var handleThenable = function (generatorWrapper, value, CustomMap, findEntry, iterateEntries) {\n    var createCircularNode = false;\n    var entryIdCounter = function (value) {\n      if (!createCircularNode) {\n        createCircularNode = true;\n        CustomMap.call(iterateEntries, value);\n      }\n    };\n    var key = function (value) {\n      if (!createCircularNode) {\n        createCircularNode = true;\n        findEntry.call(iterateEntries, value);\n      }\n    };\n    try {\n      value.call(generatorWrapper, entryIdCounter, key);\n    } catch (value) {\n      key(value);\n    }\n  };\n  var finalizePromise = function (generatorWrapper) {\n    if (!generatorWrapper.isDone) {\n      generatorWrapper.isDone = true;\n      enqueueTask(generatorWrapper.executeCallbacks, generatorWrapper);\n    }\n  };\n  var networkVersion = function (generatorWrapper) {\n    var value = null;\n    if (generatorWrapper.tasks) {\n      value = generatorWrapper.tasks;\n      generatorWrapper.tasks = value.next;\n      value.next = null;\n    }\n    if (!generatorWrapper.tasks) {\n      generatorWrapper.createDeferred = null;\n    }\n    return value;\n  };\n  PromisePolyfill.prototype.executeCallbacks = function () {\n    for (var generatorWrapper; generatorWrapper = networkVersion(this);) {\n      rejectPromiseChainNode(this, generatorWrapper, this.entryIdCounter, this.onFulfilled);\n    }\n    this.isDone = false;\n  };\n  var rejectPromiseChainNode = function (generatorWrapper, value, CustomMap, findEntry) {\n    if (CustomMap == 3 && value.tasks && !value.createDeferred) {\n      for (; generatorWrapper && generatorWrapper.handleAsync; generatorWrapper = generatorWrapper.setTimeoutWrapper) {\n        generatorWrapper.handleAsync = false;\n      }\n    }\n    if (value.entryIdCounter) {\n      value.entryIdCounter.setTimeoutWrapper = null;\n      callHandler(value, CustomMap, findEntry);\n    } else {\n      try {\n        if (value.createDeferred) {\n          value.setTimeoutWrapper.call(value.context);\n        } else {\n          callHandler(value, CustomMap, findEntry);\n        }\n      } catch (iterateEntries) {\n        logError.call(null, iterateEntries);\n      }\n    }\n    releaseObject(promiseChainNodePool, value);\n  };\n  var callHandler = function (generatorWrapper, value, CustomMap) {\n    if (value == 2) {\n      generatorWrapper.setTimeoutWrapper.call(generatorWrapper.context, CustomMap);\n    } else if (generatorWrapper.tasks) {\n      generatorWrapper.tasks.call(generatorWrapper.context, CustomMap);\n    }\n  };\n  var reportUnhandledRejection = function (generatorWrapper, value) {\n    generatorWrapper.handleAsync = true;\n    enqueueTask(function () {\n      if (generatorWrapper.handleAsync) {\n        logError.call(null, value);\n      }\n    });\n  };\n  var logError = deferError;\n  var CancellationError = function (generatorWrapper) {\n    CustomError.call(this, generatorWrapper);\n  };\n  inheritPrototype(CancellationError, CustomError);\n  CancellationError.prototype.name = \"cancel\";\n  var Timer = function (generatorWrapper, value) {\n    AdEnvironmentConfig.call(this);\n    this.tasks = generatorWrapper || 1;\n    this.entryIdCounter = value || globalScope;\n    this.setTimeoutWrapper = bindOrWrapFunction(this.getObjectPathValue, this);\n    this.handleAsync = Date.now();\n  };\n  inheritPrototype(Timer, AdEnvironmentConfig);\n  setTimeoutWrapper = Timer.prototype;\n  setTimeoutWrapper.enabled = false;\n  setTimeoutWrapper.getType = null;\n  setTimeoutWrapper.getObjectPathValue = function () {\n    if (this.enabled) {\n      var generatorWrapper = Date.now() - this.handleAsync;\n      if (generatorWrapper > 0 && generatorWrapper < 0.8 * this.tasks) {\n        this.getType = this.entryIdCounter.setTimeout(this.setTimeoutWrapper, this.tasks - generatorWrapper);\n      } else {\n        if (this.getType) {\n          this.entryIdCounter.clearTimeout(this.getType);\n          this.getType = null;\n        }\n        this.dispatchEvent(\"tick\");\n        if (this.enabled) {\n          this.stopTimer();\n          this.startTimer();\n        }\n      }\n    }\n  };\n  setTimeoutWrapper.startTimer = function () {\n    this.enabled = true;\n    if (!this.getType) {\n      this.getType = this.entryIdCounter.setTimeout(this.setTimeoutWrapper, this.tasks);\n      this.handleAsync = Date.now();\n    }\n  };\n  setTimeoutWrapper.stopTimer = function () {\n    this.enabled = false;\n    if (this.getType) {\n      this.entryIdCounter.clearTimeout(this.getType);\n      this.getType = null;\n    }\n  };\n  setTimeoutWrapper.getAdEnvironment = function () {\n    Timer.executeGeneratorAsPromise.getAdEnvironment.call(this);\n    this.stopTimer();\n    delete this.entryIdCounter;\n  };\n  var setAsyncTimeout = function (generatorWrapper, value, CustomMap) {\n    if (typeof generatorWrapper === \"function\") {\n      if (CustomMap) {\n        generatorWrapper = bindOrWrapFunction(generatorWrapper, CustomMap);\n      }\n    } else if (generatorWrapper && typeof generatorWrapper.handleEvent == \"function\") {\n      generatorWrapper = bindOrWrapFunction(generatorWrapper.handleEvent, generatorWrapper);\n    } else {\n      throw Error(\"Invalid listener argument\");\n    }\n    if (Number(value) > 2147483647) {\n      return -1;\n    } else {\n      return globalScope.setTimeout(generatorWrapper, value || 0);\n    }\n  };\n  var createTimerPromise = function (generatorWrapper, value) {\n    var CustomMap = null;\n    return new PromisePolyfill(function (findEntry, iterateEntries) {\n      CustomMap = setAsyncTimeout(function () {\n        findEntry(value);\n      }, generatorWrapper);\n      if (-1 == CustomMap) {\n        iterateEntries(Error(\"Failed to schedule timer.\"));\n      }\n    }).settlePromise(function (findEntry) {\n      globalScope.clearTimeout(CustomMap);\n      throw findEntry;\n    });\n  };\n  var getCurrentTimestamp = function () {\n    return Math.roundRectangle(Date.now() / 1000);\n  };\n  var SimpleStore = function () {\n    this.entryIdCounter = {};\n    return this;\n  };\n  SimpleStore.prototype.removeElement = function (generatorWrapper) {\n    var value = this.entryIdCounter;\n    if (generatorWrapper in value) {\n      delete value[generatorWrapper];\n    }\n  };\n  SimpleStore.prototype.set = function (generatorWrapper, value) {\n    this.entryIdCounter[generatorWrapper] = value;\n  };\n  var setBitFlag = function (generatorWrapper, value) {\n    generatorWrapper.entryIdCounter.hasStringPrototypeNormalize = getObjectPropertyOrDefault(generatorWrapper.entryIdCounter, \"eb\", 0) | value;\n  };\n  SimpleStore.prototype.get = function (generatorWrapper) {\n    return getObjectPropertyOrDefault(this.entryIdCounter, generatorWrapper, null);\n  };\n  var globalStore = null;\n  var GlobalStoreConstructor = function () {\n    this.entryIdCounter = {};\n    this.tasks = 0;\n  };\n  var getGlobalStore = function () {\n    if (!globalStore) {\n      globalStore = new GlobalStoreConstructor();\n    }\n    return globalStore;\n  };\n  var registerGlobalValue = function (generatorWrapper, value) {\n    generatorWrapper.entryIdCounter[value.getAdName()] = value;\n  };\n  var GlobalValue = function (generatorWrapper, value) {\n    this.createDeferred = generatorWrapper;\n    this.setTimeoutWrapper = true;\n    this.entryIdCounter = value;\n  };\n  GlobalValue.prototype.getAdName = function () {\n    return this.createDeferred;\n  };\n  GlobalValue.prototype.getAdStateValue = function () {\n    return this.entryIdCounter;\n  };\n  GlobalValue.prototype.tasks = function () {\n    return String(this.entryIdCounter);\n  };\n  var BooleanGlobalValue = function (generatorWrapper, value) {\n    GlobalValue.call(this, String(generatorWrapper), value);\n    this.handleAsync = generatorWrapper;\n    this.entryIdCounter = !!value;\n  };\n  inheritPrototype(BooleanGlobalValue, GlobalValue);\n  BooleanGlobalValue.prototype.tasks = function () {\n    if (this.entryIdCounter) {\n      return \"1\";\n    } else {\n      return \"0\";\n    }\n  };\n  var RectGlobalValue = function (generatorWrapper, value) {\n    GlobalValue.call(this, generatorWrapper, value);\n  };\n  inheritPrototype(RectGlobalValue, GlobalValue);\n  RectGlobalValue.prototype.tasks = function () {\n    if (this.entryIdCounter) {\n      return Math.roundRectangle(this.entryIdCounter.top) + \".\" + Math.roundRectangle(this.entryIdCounter.left) + \".\" + (Math.roundRectangle(this.entryIdCounter.top) + Math.roundRectangle(this.entryIdCounter.height)) + \".\" + (Math.roundRectangle(this.entryIdCounter.left) + Math.roundRectangle(this.entryIdCounter.width));\n    } else {\n      return \"\";\n    }\n  };\n  var parseRectFromString = function (generatorWrapper) {\n    if (generatorWrapper.match(/^-?[0-9]+\\.-?[0-9]+\\.-?[0-9]+\\.-?[0-9]+$/)) {\n      generatorWrapper = generatorWrapper.split(\".\");\n      var value = Number(generatorWrapper[0]);\n      var CustomMap = Number(generatorWrapper[1]);\n      return new RectGlobalValue(\"\", new RectangleDimensions(CustomMap, value, Number(generatorWrapper[3]) - CustomMap, Number(generatorWrapper[2]) - value));\n    }\n    return new RectGlobalValue(\"\", new RectangleDimensions(0, 0, 0, 0));\n  };\n  var calculateBoundingRect = function (generatorWrapper) {\n    var value = new RectangleDimensions(-Number.MAX_VALUE / 2, -Number.MAX_VALUE / 2, Number.MAX_VALUE, Number.MAX_VALUE);\n    var CustomMap = new RectangleDimensions(0, 0, 0, 0);\n    if (!generatorWrapper || generatorWrapper.length == 0) {\n      return CustomMap;\n    }\n    for (var findEntry = 0; findEntry < generatorWrapper.length; findEntry++) {\n      generatorWrapper: {\n        var iterateEntries = value;\n        var createCircularNode = generatorWrapper[findEntry];\n        var entryIdCounter = Math.max(iterateEntries.left, createCircularNode.left);\n        var key = Math.min(iterateEntries.left + iterateEntries.width, createCircularNode.left + createCircularNode.width);\n        if (entryIdCounter <= key) {\n          var value = Math.max(iterateEntries.top, createCircularNode.top);\n          createCircularNode = Math.min(iterateEntries.top + iterateEntries.height, createCircularNode.top + createCircularNode.height);\n          if (value <= createCircularNode) {\n            iterateEntries.left = entryIdCounter;\n            iterateEntries.top = value;\n            iterateEntries.width = key - entryIdCounter;\n            iterateEntries.height = createCircularNode - value;\n            iterateEntries = true;\n            break generatorWrapper;\n          }\n        }\n        iterateEntries = false;\n      }\n      if (!iterateEntries) {\n        return CustomMap;\n      }\n    }\n    return value;\n  };\n  var getElementRectangle = function (generatorWrapper, value) {\n    var CustomMap = generatorWrapper.getBoundingClientRect();\n    generatorWrapper = calculateFrameOffset(generatorWrapper, value);\n    return new RectangleDimensions(Math.roundRectangle(generatorWrapper.inheritPrototype), Math.roundRectangle(generatorWrapper.globalScope), Math.roundRectangle(CustomMap.right - C"